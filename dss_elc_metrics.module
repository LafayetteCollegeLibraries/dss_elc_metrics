<?php

require_once dirname(__FILE__) . '/includes/apachesolr.inc';

/**
 * Implements hook_menu()
 *
 */
function dss_elc_metrics_menu() {

  $items = array(
		 'metrics' => array(
				    'page callback' => 'dss_elc_metrics_get_node_metrics_ajax',
				    'access callback' => TRUE,
				    ),
		 'dss_elc_metrics/univariate' => array(
						       'page callback' => 'dss_elc_metrics_univariate_ajax',
						       'access callback' => TRUE
						       ),
		 'bivariate' => array(
				      'page callback' => 'dss_elc_metrics_get_bivariate_ajax',
				      'access callback' => TRUE),
		 'network' => array(
				    'page callback' => 'dss_elc_metrics_get_network_ajax',
				    'access callback' => TRUE),
//		 'loaned/items' => array(
//					 'page callback' => 'dss_elc_metrics_get_items_loaned_ajax',
//					 'access callback' => TRUE,
//					 ),
//		 'persons/loaned/items' => array(
//						 'page callback' => 'dss_elc_metrics_get_items_loaned_persons_ajax',
//						 'access callback' => TRUE,
//						 ),
		 'datatable_person/views/people' => array('page callback' => 'dss_elc_metrics_get_people',
							  'access callback' => TRUE,
							  ),
		 'datatable_item/views/items' => array('page callback' => 'dss_elc_metrics_get_items',
						       'access callback' => TRUE,
						       ),
		 'datatable_loan/views/loans' => array('page callback' => 'dss_elc_metrics_get_loans',
						       'access callback' => TRUE,
						       ),
		 );

  return $items;
}

function dss_elc_metrics_univariate_summation($bundle, $field) {

  $samples = array();

  $samples = array('sample' => array('domain' => 256));

  $bundles = $bundle == 'item' ? array('item','book','periodical') : array($bundle);

  $data = array();

  // Connect and attempt to retrieve the samples from the cache
  list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('metrics_univariate_cache_sum');
  $mongo_key = 'metrics_univariate_cache_sum_' . implode('_', array($bundle, $field));

  // If the samples have been cached, retrieve them
  $cached = $mongo_collection->findOne(array('query' => $mongo_key));

  if($cached) {

    $connections = $mongo->getConnections();

    // Uncertain as to why this is necessary
    foreach ( $connections as $conn ) {
      
      $closed = $mongo->close( $conn['hash'] );
    }
    return $cached['data'];
  }

  // Query Solr and retrieve the faceted values for the field
  $query = array();
  $data = array();

  $field_solr_map = array('field_artifact_was_authored_by' => 'sm_field_artifact_was_authored_b',
			  'field_item_subject' => 'sm_vid_Item_Subjects',
			  'field_item_format' => 'bundle_name',

			  'field_human_gender' => 'bs_field_gender',
			  'field_person_type' => 'sm_vid_Person_Types',

			  'field_bib_rel_subject' => 'sm_field_bib_rel_subject',
			  'field_loan_shareholder' => 'sm_field_loan_shareholder',
			  'field_bib_rel_object' => 'sm_field_bib_rel_object',
			  'field_loan_duration_value_0' => 'is_field_loan_duration_value'
			  );

  $entity_reference_fields = array('sm_field_artifact_was_authored_b' => array('human'),
				   
				   'sm_field_bib_rel_subject' => array('human'),
				   'sm_field_loan_shareholder' => array('human'),
				   'sm_field_bib_rel_object' => array('item', 'book', 'periodical')
				   );

  $solr_field_sample_label_map = array('sm_field_artifact_was_authored_b' => 'Author',
				       'sm_vid_Item_Subjects' => 'Subject',
				       'bundle_name' => 'Type',

				       'bs_field_gender' => 'Gender',
				       'sm_vid_Person_Types' => 'Type');

  $field = $field_solr_map[$field];

  $data = array();
  $query = array();

  // Iterate through all loans

  // ...and if this data set hasn't been cached, prepare for delayed response
  set_time_limit(540 * 4);

  // Iterate through all loans
  list($query, $results) = dss_elc_metrics_solr_query(array('loan'), $query, 100000);
  //list($query, $results) = dss_elc_metrics_solr_query(array('loan'), $query, 1000);

  $loans = $results->response->docs;
  $samples = array();
  $domains = array();

  foreach($loans as $loan_doc) {

    $query = array();

    // This should be iterative for multiple volumes borrowed during a single loan
    $manifest_nid = $loan_doc->sm_field_bib_rel_object;
    $query[] = 'sm_field_item_embodies:"' . $manifest_nid[0] . '"';
    //list($query, $results) = dss_elc_metrics_solr_query($bundles_v, $query, 1000000);
    list($query, $results) = dss_elc_metrics_solr_query(array('item', 'book', 'periodical'), $query, 1);
    $item_doc = $results->response->docs[0];

    $human_docs = array();

    // Retrieve the related humans
    foreach(array('sm_field_bib_rel_subject',
		  'sm_field_loan_shareholder') as $human_reference_field) {
      
      // This should be iterative for multiple volumes borrowed during a single loan
      $human_nid = $loan_doc->$human_reference_field;
      preg_match('/node\:(\d+)/', $human_nid[0], $m);
      $human_nid = intval($m[1]);

      $query = array();
      $query[] = 'entity_id:"' . $human_nid . '"';

      list($query, $results) = dss_elc_metrics_solr_query(array('human'), $query, 1);

      $human_field = $field_v;
      $docs = $results->response->docs;

      // This assumes that there is one (and only one) Shareholder or Representative specified within a Loan record
      if(!empty($docs)) {

	$human_docs[] = $docs[0];
      }
    }

    //! @todo Refactor
    if($bundle == 'item') {

      $domain = is_array($item_doc->$field) ? $item_doc->$field : array($item_doc->$field);

      if(empty($domain) or empty($domain[0])) {

	$domains[] = 'Unknown';
      } elseif(array_key_exists($field, $entity_reference_fields)) {

	preg_match('/node\:(\d+)/', $domain[0], $m);
	$rel_nid = intval($m[1]);
	
	// Retrieve the label for entity reference fields
	$query = array();
	$query[] = 'entity_id:' . $rel_nid;
	
	$rel_bundles = $entity_reference_fields[$field];
	
	list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1000000);
	
	$rel_docs = $results->response->docs;
	
	if(empty($rel_docs)) {
	  
	  $domains[] = 'Unknown';
	} else {
	  
	  //$domains[] = $rel_docs[0]->label;
	  $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	}
      } else {
	
	$domains[] = $domain[0];
      }
      
    } elseif($bundle == 'human') {
      
      $human_field = $field;
      
      // As there are multiple Human Nodes related to any given Loan Node...
      foreach($human_docs as $human_doc) {
	
	$human_doc = $results->response->docs[0];
	
	$domain = is_array($human_doc->$field) ? $human_doc->$field : array($human_doc->$field);
	
	if(empty($domain) or empty($domain[0])) {
	  
	  if(array_search('Unknown', $domains) === FALSE) {
	    
	    $domains[] = 'Unknown';
	  }
	} elseif(array_key_exists($field, $entity_reference_fields)) {
	  
	  preg_match('/node\:(\d+)/', $domain[0], $m);
	  $rel_nid = intval($m[1]);
	  
	  // Retrieve the label for entity reference fields
	  $query = array();
	  $query[] = 'entity_id:' . $rel_nid;
	  
	  $rel_bundles = $entity_reference_fields[$field];
	  
	  list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1);
	  
	  $rel_docs = $results->response->docs;
	  
	  if(empty($rel_docs)) {
	    
	    $domains[] = 'Unknown';
	  } else {
	    
	    //$domains[] = $rel_docs[0]->label;
	    $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	  }
	} else {
	  
	  $domains[] = $domain[0];
	}
      }
    } elseif($bundle == 'loan') {
      
      $domain = is_array($loan_doc->$field) ? $loan_doc->$field : array($loan_doc->$field);
      
      if(empty($domain) or empty($domain[0])) {
	
	$domains[] = 'Unknown';
      } elseif(array_key_exists($field, $entity_reference_fields)) {
	
	preg_match('/node\:(\d+)/', $domain[0], $m);
	$rel_nid = intval($m[1]);
	
	// Retrieve the label for entity reference fields
	$query = array();
	$query[] = 'entity_id:' . $rel_nid;
	
	$rel_bundles = $entity_reference_fields[$field];
	
	// Only retrieve one document
	list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1);
	
	$rel_docs = $results->response->docs;
	
	if(empty($rel_docs)) {
	  
	  $domains[] = 'Unknown';
	} else {
	  
	  $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	}
      } else {
	
	$domains[] = $domain[0];
      }
    }
  }

  $label_map = array('loan' => 'Loans',
		     'item' => 'Items',
		     'human' => 'People'
		     );

  $label = $label_map[$bundle];
  if(!array_key_exists($label, $samples)) {

    $samples[$label] = array();
  }

  foreach($domains as $domain) {

    if(!array_key_exists($domain, $samples[$label])) {

      $samples[$label][$domain] = 1;
    } else {

      $samples[$label][$domain]++;
    }
  }

  $mongo_collection->update(array('query' => $mongo_key),
			    array('query' => $mongo_key,
				  'data' => $samples),
			    array('upsert' => TRUE));

  $connections = $mongo->getConnections();

  // Uncertain as to why this is necessary
  foreach ( $connections as $conn ) {
      
    $closed = $mongo->close( $conn['hash'] );
  }
  
  return $samples;
}

/**
 * @author griffinj
 * Retrieve the data for the univariate relationships
 *
 */
function dss_elc_metrics_univariate($bundle, $field, $chart = 'bar', $metric = 'sum') {

  /**
   * @todo Integrate MongoDB caching
   *
   */
  $mongo_id = 'quantitative';
  $collection_name = 'dss_elc_metrics_loans';

  // Cache the domains
  $mongo_id = $field;
  $collection_name = 'dss_elc_metrics_loans';

  /*
   * Retrieve the data
   *
   */
  $data = array();

  switch($metric) {
      
  case 'sum':
  default:

    $samples = array_merge($data, dss_elc_metrics_univariate_summation($bundle, $field));
  }

  // The closure passed to uasort() won't be invoked if the domain values for a single sample must be sorted
  foreach($samples as $domain => &$domain_values) {

    uasort($domain_values, function($domain_u, $domain_v) {

	if($domain_u == $domain_v) {

	  $result = 0;
	} else {

	  // This shall vary depending upon whether the values are sorted by minimum or maximum
	  $result = ($domain_u > $domain_v) ? -1 : 1;
	}

	return $result;
      });

    // Slice by a length specified within the site configuration
    $domain_values = array_slice($domain_values, 0, 10);
  }
  
  uasort($samples, function($domain_values_u, $domain_values_v) {

      $domain_values_u_init = reset($domain_values_u);
      $domain_values_v_init = reset($domain_values_v);

      if($domain_values_u_init == $domain_values_v_init) {

	$domain_values_u_length = count($domain_values_u);
	$domain_values_v_length = count($domain_values_v);

	if($domain_values_u_length == $domain_values_v_length) {

	  $result = 0;
	} else {

	  // Prefer the least number of values within the sample (for the purposes of slicing the array)
	  $result = ($domain_values_u_length < $domain_values_v_length) ? -1 : 1;
	}
      } else {

	// This shall vary depending upon whether the values are ordered by minimum or maximum
	$result = ($domain_values_u_init > $domain_values_v_init ? -1 : 1);
      }

      return $result;
    });

  //! @todo Reverse for sorting by the minimum

  // Slice by a length specified within the site configuration
  $samples = array_slice($samples, 0, 10);

  // Construct the labels
  $labels = array();

  // Structure the data for the NVD3 widget
  if($chart == 'bar' or $chart == 'line') {

    $domain_index = 0;
    foreach($samples as $group => $value) {

      $values = array();

      foreach($value as $x => $y) {

	// Assign arbitrary values for each member of the nominal set
	// Each value must map only to a single nominal value
	$labels[] = $x;
	
	$values[] = array('x' => $domain_index,
			  'y' => $y);

	$domain_index++;
      }

      $data[] = array('key' => $group,
		      'values' => $values);
    }

  } elseif($chart == 'pie') {

    foreach($samples as $group => $value) {

      foreach($value as $x => $y) {

	$data[] = array('label' => $x,
			  'value' => $y);
      }
    }
  } elseif($chart == 'cumulative_line') {

    foreach($samples as $group => $value) {

      $values = array();
      foreach($value as $x => $y) {

	$values[] = array($x, $y);
      }

      $data[] = array('key' => $group,
		      'values' => $values);
    }
  }

  $response = array('samples' => $data,
		    'labels' => $labels);

  return $response;
}

function dss_elc_metrics_univariate_ajax($content_type = NULL, $field = NULL) {

  if(empty($_POST)) {

    // Communicating using JSON

    // The inputstream module should be utilized here in order to avoid breaking when more than one module accesses the stream concurrently:
    $data = file_get_contents("php://input");
    $data = json_decode($data, TRUE);

    drupal_json_output($data);
  } else {

    foreach(array('bundle', 'field', 'chart', 'metric') as $param) {

      if(array_key_exists($param, $_POST)) {

	$data[$param] = $_POST[$param];
      }
    }
  }

  if(!empty($data)) {
    
    // The JSON must be normalized
    //if(array_keys($data) === array('bundle', 'field', 'chart', 'metric')) {
    if(array_keys($data) === array('bundle', 'field', 'chart')) {

      drupal_json_output(dss_elc_metrics_univariate($data['bundle'], $data['field'], $data['chart'], $data['metric']));
    }
  }
}

function dss_elc_metrics_univariate_ajax_deprecated($content_type = NULL, $field = NULL) {

  $content_type = array_key_exists('bundle', $_POST) ? $_POST['bundle'] : $content_type;
  $field = array_key_exists('field', $_POST) ? $_POST['field'] : $field;

  if(!isset($field) || !isset($content_type)) {

    drupal_json_output(array());
    return;
  }

  // Refactor
  // Label mapping
  $info = field_info_instance('node', $field, $content_type);

  $y_axis = array('label' => 'Quantity',
		  'type' => 'ratio',
		  'axis' => 'y');

  /**
   * @todo Refactor for different types of metrics (e. g. summation, median, mode...)
   *
   */
  if(true) {

    $y_axis['property'] = 'value';
  }

  // MongoDB caching
  

  // First, retrieve every entity with this relationship
  $entity_query = new EntityFieldQuery();
  $entity_query->entityCondition('entity_type', 'node');
  $entity_query->entityCondition('bundle', $content_type);
  $entity_query->range(0,100);
  $results = $entity_query->execute();
  //$_object = node_load(array_pop(array_keys($entities['node'])));

  $data = array();
  /**
   * {"data":[
   * {"domain":" Buffon, Georges Louis Leclerc, Comte de","values":[{"sample":"Unknown","value":8}]},
   * {"domain":"Campbell, Donald ","values":[{"sample":"Unknown","value":2}]}
   */

  /**
   * @todo Refactor
   */
  $DSS_ELC_TAXON_FIELDS = array('field_item_subject');

  foreach(entity_load('node', array_keys($results['node'])) as $entity) {

    //$field_value = empty($entity->$field) ? 'Unknown' : $entity->$field[0];
    if(empty($entity->$field)) {

      $field_value = 'Unknown';
    } else {

      //if(in_array($field, )) {
      if(true) {

      } else {

	$field_value = $entity->$field;
	$field_value = $field_value[0];
      }
    }

    if(!array_key_exists($field_value, $data)) {

      $data[$field_value] = 1;
    } else {

      $data[$field_value] += 1;
    }
  }

  print json_encode($data);

  // Linear transformation for D3
  $output_data = array();
  $metrics = array();

  foreach($data as $field_value => $quantity) {

    $output_data[] = array('domain' => $field_value,
			   'values' => array(array('sample' => $field_value,
						   'value' => $quantity)));

    /**
     * @todo Integrate with a remote service call to the QAS
     *
     */
    $metrics[$field_value] = array('sample' => $field_value,
				   'aMean' => mt_rand() / mt_getrandmax(),
				   'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				   'mode' => mt_rand() / mt_getrandmax(),
				   'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				   'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				   'distribution' => 'Poisson');
  }

  /**
   * Test data
   * @todo Remove
   */

  /*
  foreach(array('Alpha', 'Beta', 'Gamma') as $test_value) {

    $output_data[] = array('domain' => $test_value,
			   'values' => array(array('sample' => $test_value,
						   'value' => rand(1, 100))));
    
    $metrics[$test_value] = array('sample' => $test_value,
				  'aMean' => mt_rand() / mt_getrandmax(),
				  'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				  'mode' => mt_rand() / mt_getrandmax(),
				  'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				  'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				  'distribution' => 'Poisson');
  }
  */


  $output = array('data' => $output_data,
		  'metrics' => $metrics,
		  'metadata' => array('x' => array('label' => $info['label'],
						   'property' => 'domain',
						   'type' => $scale_type ? $scale_type : 'nominal',
						   'axis' => 'x'),
				      'y' => $y_axis)
		  );

  drupal_json_output($output);
}

function __dss_elc_metrics_univariate_ajax($contentType = NULL, $field = NULL) {

  if(true) {

    return 'trace';
  }

  // bundle=human&field=field_human_occupation
  $contentType = array_key_exists('bundle', $_POST) ? $_POST['bundle'] : $contentType;
  $field = array_key_exists('field', $_POST) ? $_POST['field'] : $field;

  if(!isset($field) || !isset($contentType)) {

    drupal_json_output(array());
    return;
  }

  /**
   * @todo Integrate MongoDB caching
   *
   */
  $mongo_id = 'quantitative';
  $collection_name = 'dss_elc_metrics_loans';

  // Cache the domains
  $mongo_id = $field_u;
  $collection_name = 'dss_elc_metrics_loans';

  //$domains = dss_elc_metrics_cache_get($mongo_id, $collection_name);

  /** @todo Integrate MongoDB caching */
  /*
  $domains = dss_elc_metrics_cache_get_domains($field_u);

  if(!isset($domains)) {
    
    $domains = dss_elc_metrics_cache_domains($bundle_u, $field_u, $bundle_v, $field_v);
  }
  */

  $metrics = array();

  // Apply a linear transform for D3
  $output = array();

  foreach($domains as $domain => $samples) {

    $sample_values = array();
    
    foreach($samples as $sample => $qty) {
      
      $sample_values[] = array('sample' => $sample,
			       'value' => $qty);

      /**
       * @todo Integrate with a remote service call to the QAS
       *
       */
      $metrics[$sample] = array('sample' => $sample,
				'aMean' => mt_rand() / mt_getrandmax(),
				'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				'mode' => mt_rand() / mt_getrandmax(),
				'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				'distribution' => 'Poisson');
    }

    // Refactor
    if($field_u == 'field_loan_duration') {
     
      // Work-around
      $output[] = array('domain' => (string) $domain,
			'values' => $sample_values);
    } else {

      $output[] = array('domain' => $domain,
			'values' => $sample_values);
    }
  }

  // Refactor
  // Label mapping
  $info = field_info_instance('node', $field, $contentType);

  $y_axis = array('label' => $info['label'],
		  'type' => 'ratio',
		  'axis' => 'y');

  /**
   * @todo Refactor for different types of metrics (e. g. summation, median, mode...)
   *
   */
  if(true) {

    $y_axis['property'] = 'value';
  }

  /*
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
   */

  // Wrap the Object with the appropriate metadata
  /*
  return array('data' => $output,
	       'metrics' => $metrics,
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
	       );
  */
  
  /**
   * Find all U entities related to V entities through relation R
   * This should be a simple SPARQL query, but ARC2 doesn't support PostgreSQL
   *
   */

  // First, retrieve every entity with this relationship
  $entity_query = new EntityFieldQuery();
  $entity_query->entityCondition('entity_type', 'node');
  //$entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
  $entities = $entity_query->execute();
  $_object = node_load(array_pop(array_keys($entities['node'])));

  // Retrieve all bundles from the ELC database sorted by the values for the field

  //$query = db_select('node', 'n');

  /*
  $query->join("field_data_field_bib_rel_object", 'bib_rel_object', 'bib_rel_object.field_bib_rel_object_target_id=n.nid'); // Retrieve all field records for all NID's specified in the book loan records
  $query->join('node', 'loan', 'loan.nid=bib_rel_object.entity_id'); // Retrieve all related loan records
  $query->join("field_data_field_bib_rel_subject", 'bib_rel_subject', 'bib_rel_subject.entity_id=loan.nid'); // Retrieve all borrowers
  $query->join("field_data_field_loan_duration", 'loan_duration', 'loan_duration.entity_id=loan.nid'); // Retrieve the duration of the loan
  */

  //$query->condition('n.type', $contentType, '=');

  /*
  $query->fields('bib_rel_object', array('field_bib_rel_object_target_id'));
  $query->fields('bib_rel_subject', array('field_bib_rel_subject_target_id'));
  $query->fields('loan_duration', array('field_loan_duration_value', 'field_loan_duration_value2'));
  */

  /**
   * Need limited data set for testing
   * @todo Disable
   */
  //$query->range(0,10);
  //$records = $query->execute();

  if(true) {

    return $records;
  }

  $index = array();
  $json_record_values = array();

  /*
    $info = field_info_instance($entity_type, $field_name, $bundle_name);

    $label = $info['label'];
   */

  foreach($records as $record) {

    $_object = node_load($record->field_bib_rel_object_target_id);

    // If this is a manifestation, retrieve the original work
    if($_object->type == 'manifestation') {

      $entity_query = new EntityFieldQuery();
      $entity_query->entityCondition('entity_type', 'node');
      $entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
      $entities = $entity_query->execute();

      $_object = node_load(array_pop(array_keys($entities['node'])));
    }

    // Refactor
    if($field_u != 'field_loan_duration') {

      $_field_u = $_object->$field_u;
    }

    $_subject = node_load($record->field_bib_rel_subject_target_id);

    /**
     * @note Handling for List fields
     * Book/Periodical/Item: field_item_format
     * Human: field_human_gender
     *
     */
    $_field_v = $_subject->$field_v;

    // Refactor
    if(empty($_subject->$field_v)) {

      $_sample_name = 'Unknown';
    } else {
      
      if($field_v == 'field_human_gender') {

	$_field = field_info_field($field_v);
	$_values = list_allowed_values($_field);
	$_sample_name = array_pop($_field_v['und']);
	$_sample_name = $_values[$_sample_name['value']];
      } elseif($field_v == 'field_person_location' ||
	       $field_v == 'field_person_membership') {
	
	$entity_id = array_pop($_field_v['und']);
	$entity = node_load($entity_id['target_id']);
	
	$_sample_name = $entity->title;
      }
    }
    
    // For NULL List field values
    if(!$_sample_name) {
      
      $_sample_name = 'Unknown';
    }

    // Term Reference fields
    // Refactor for array
    if($field_u == 'field_human_occupation' ||
       $field_u == 'field_person_type' ||
       $field_u == 'field_item_subject' ||
       $field_u == 'field_artifact_type') {
      
      // For the handling of NULL values
      if(!$_field_u) {
	
	$_field_u = array('und' => array('Unknown'));
      }
      
      foreach($_field_u['und'] as $term) {
	  
	if(!array_key_exists('tid', $term)) {
	  
	  $domain = 'Unknown';
	} else {

	  $term = taxonomy_term_load($term['tid']);
	  $domain = $term->name;
	}

	if(!array_key_exists($domain, $json_record_values)) {

	  $json_record_values[$domain] = array($_sample_name => 1);	  
	} else {
	  
	  $json_record_values[$domain][$_sample_name]++;
	}
      }
    } elseif($field_u == 'field_artifact_was_authored_by') { // Entity References
      
      $entity_id = array_pop($_field_u['und']);
      $entity = node_load($entity_id['target_id']);
      
      $domain = $entity->field_person_name['und'][0]['value'];
      
      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_item_format') { // Refactor

      $_field = field_info_field($field_u);
      $_values = list_allowed_values($_field);
      $_domain = array_pop($_field_u['und']);
      $domain = $_values[$_domain['value']];

      // For NULL values
      if(!$domain) {

	$domain = 'Unknown';
      }

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field == 'field_loan_duration') { // Loan duration

      // Parse from a UNIX timestamp
      $domain = $record->field_loan_duration_value;
      $date = new DateObject($domain);
      $domain = $date->format('Ymd');

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }

      // Also, set the type of scale to "temporal"
      $scale_type = 'temporal';
    }
  }

  $metrics = array();

  // Apply a linear transform for D3
  $output = array();
  foreach($json_record_values as $domain => $samples) {

    $sample_values = array();
    
    foreach($samples as $sample => $qty) {
      
      $sample_values[] = array('sample' => $sample,
			       'value' => $qty);

      $metrics[$sample] = array('sample' => $sample,
				'aMean' => mt_rand() / mt_getrandmax(),
				'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				'mode' => mt_rand() / mt_getrandmax(),
				'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				'distribution' => 'Poisson');
    }

    // Refactor
    if($field_u == 'field_loan_duration') {
     
      // Work-around
      $output[] = array('domain' => (string) $domain,
			'values' => $sample_values);
    } else {

      $output[] = array('domain' => $domain,
			'values' => $sample_values);
    }
  }

  // Refactor
  // Label mapping
  $info_u = field_info_instance('node', $field_u, $field_u == 'field_loan_duration' ? 'loan' : 'item');
  $info_v = field_info_instance('node', $field_v, 'human');

  $y_axis = array('label' => 'Loans',
		  'type' => 'ratio',
		  'axis' => 'y');

  // Refactor
  //if($field_u != 'field_loan_duration') {
  if(true) {

    $y_axis['property'] = 'value';
  }

  // Wrap the Object with the appropriate metadata
  return array('data' => $output,
	       'metrics' => $metrics,
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
	       );
}

/**
 * @author griffinj@lafayette.edu
 *
 * Case: Analyze humans by gender
 * Case: Analyze humans by occupation
 * Case: Analyze humans by location
 * Case: Analyze humans by membership
 * Case: Analyze humans by type
 *
 * Case: Analyze books by subject
 * Case: Analyze books by format
 * Case: Analyze books by type
 *
 */
function _dss_elc_metrics_get_node_metrics_ajax($contentType = NULL, $field = NULL) {

  // bundle=human&field=field_human_occupation
  $contentType = array_key_exists('bundle', $_POST) ? $_POST['bundle'] : $contentType;
  $field = array_key_exists('field', $_POST) ? $_POST['field'] : $field;

  if(!isset($field) || !isset($contentType)) {

    drupal_json_output(array());
    return;
  }

  $entities = array();

  //$entities[] = dss_elc_get_node('nid', 101036);
  //$entities[] = dss_elc_get_node('nid', 101037);

  //$entities = dss_elc_get_nodes($contentType);

  $FIELD_NAME_MAP = array(
			  'gender' => 'field_human_gender',
			  'occupation' => 'field_human_occupation',
			  'membership' => 'field_person_membership',
			  'location' => 'field_person_location',
			  'subject' => 'field_item_subject',
			  'format' => 'field_item_format');

  if(array_key_exists($field, $FIELD_NAME_MAP)) {

    $field = $FIELD_NAME_MAP[$field];
  }

  /**
"metadata":{
"x":{"label":"Author(s)","property":"domain","type":"nominal","axis":"x"},
"y":{"label":"Loans","type":"ratio","axis":"y","property":"value"}}}
   */

  if($contentType == 'human') {

    $index = array();

    if($field == 'field_person_membership'
       || $field == 'field_person_location') {

      /**
       * griffinj
       * Prototype
       *
       */
      if($field == 'field_person_membership') {

	$index = array(
		       array("label" => "Arndt Family", "value" => rand(1,477)),
		       array("label" => "Mixsell Family", "value" => rand(1,477)),
		       array("label" => "Sitgreaves Family", "value" => rand(1, 477)),
		       array('label' => 'The First United Church of Christ', 'value' => rand(1, 477))
		       );
      } else {

	$index = array(
		       array("label" => "Easton", "value" => rand(1, 477)),
		       array("label" => "Northampton", "value" => rand(1, 477)),
		       array("label" => "Phillipsburg", "value" => rand(1, 477)),
		       array("label" => "Philadelphia", "value" => rand(1, 477))
		       );
      }
      drupal_json_output($index);
      return;

      foreach($entities as $human) {

	$entityRefField = $human->$field;
	
	foreach($entityRefField[$human->language] as $value) {

	  $entity = dss_elc_get_node('nid', intval($value['target_id']));

	  if(false) {

	    $nameField = $entity->field_person_name[$entity->language][0]['value'];
	  } elseif($field == 'field_person_membership'
		   || $field == 'field_person_location') {
	    
	    $nameField = $entity->title;
	  }

	  if(!array_key_exists($nameField, $index)) {
	    
	    $index[$nameField] = 1;
	  } else {
	    
	    $index[$nameField]++;
	  }
	}
      }
    } elseif($field == 'field_human_occupation'
	     || $field == 'field_person_type') {

      if($field == 'field_human_occupation') {
	
	$index = array(
		       array("label" => "Physician", "value" => rand(1, 477)),
		       array("label" => "Lawyer", "value" => rand(1, 477)),
		       array("label" => "Carpenter", "value" => rand(1, 477))
		       );
      } else {

	$index = array(
		       array("label" => "Shareholder", "value" => rand(1, 477)),
		       array("label" => "Representative", "value" => rand(1, 477))
		       );
      }
      drupal_json_output($index);
      return;

      foreach($entities as $item) {

	$taxonField = $item->$field;

	foreach($taxonField[$item->language] as $tid) {

	  $term = taxonomy_term_load($tid['tid']);

	  if(!array_key_exists($term->name, $index)) {
	  
	    $index[$term->name] = 1;
	  } else {

	    $index[$term->name]++;
	  }
	}
      }     
    } elseif($field == 'field_human_gender') {

      $GENDER_MAP = array('Male', 'Female');
      foreach($entities as $human) {

	$intField = $human->$field;

	if(!isset($intField[$human->language])) {

	  continue;
	}
	$fieldValue = $GENDER_MAP[$intField[$human->language][0]['value']];

	if(!array_key_exists($fieldValue, $index)) {
	  
	  $index[$fieldValue] = 1;
	} else {

	  $index[$fieldValue]++;
	}
      }
    }
  } elseif($contentType == 'book'
	   || $contentType == 'periodical'
	   || $contentType == 'item') {
    
    $index = array();

    // Many-to-many relationship between the subjects and books/periodicals/items
    if($field == 'field_item_subject') {

      /**
       * griffinj
       * Prototype
       *
       */
      $index = array(
		     array("label" => "Theology: General", "value" => rand(1, 1898)),
		     array("label" => "Travels and Voyages: Africa and Asia", "value" => rand(1, 1898)),
		     array("label" => "Natural Sciences and Medicine: Medicine", "value" => rand(1, 1898))
		     );
      drupal_json_output($index);
      return;

      foreach($entities as $item) {

	foreach($item->field_item_subject[$item->language] as $tid) {

	  $term = taxonomy_term_load($tid['tid']);

	  if(!array_key_exists($term->name, $index)) {
	  
	    $index[$term->name] = 1;
	  } else {

	    $index[$term->name]++;
	  }
	}
      }
    } elseif($field == 'field_item_format') {

      $index = array(
		     array("label" => "Octavo", "value" => 57),
		     array("label" => "Quarto", "value" => 42),
		     array("label" => "Duodecimo", "value" => 61));
      drupal_json_output($index);
      return;

      //drupal_json_output($field);
      $FORMAT_MAP = array('Octavo', 'Quarto', 'Duodecimo');
      foreach($entities as $item) {

	//drupal_json_output($item->field_item_format[$item->language]);
	if(!isset($item->field_item_format[$item->language])) {

	  continue;
	}
	$item_format = $FORMAT_MAP[$item->field_item_format[$item->language][0]['value']];


	if(!array_key_exists($item_format, $index)) {
	  
	  $index[$item_format] = 1;
	} else {

	  $index[$item_format]++;
	}
      }
    }
  }

  /**
  // Wrap the Object with the appropriate metadata
  return array('data' => $output,
	       'metrics' => $metrics,
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
	       );
  **/

  // For D3
  foreach($index as $key => &$value) {

    unset($index[$key]);
    $index[] = array('label' => $key,
		     'value' => $value);
  }

  drupal_json_output($index);
}

/**
 * @author griffinj@lafayette.edu
 *
 * Case: The total number books/periodicals/items loaned to a single person of a certain gender
 *
 */
function dss_elc_metrics_get_items_loaned($nid) {

  module_load_include('inc', 'dss_elc', 'includes/data_access');
  $personEntity = dss_elc_get_node('nid', intval($nid), 'person');

  // No JOIN operations permitted for entityCondition queries in Drupal 7
  // Integrate with the RDF Indexer module
  $loans = dss_elc_get_nodes('loan', 'field_bib_rel_subject', intval($personEntity->nid), FIELD_TYPE_ENTITY_REF);

  $items = array();
  foreach($loans as $loan) {

    // These are manifestations
    foreach($loan->field_bib_rel_object[$loan->language] as $item) {

      $manif = dss_elc_get_node('nid', intval($item['target_id']), 'item');

      // Refactor
      foreach(dss_elc_get_nodes('book', 'field_item_embodies', intval($manif->nid), FIELD_TYPE_ENTITY_REF) as $book) {

	$items[] = $book;
      }
      foreach(dss_elc_get_nodes('periodical', 'field_item_embodies', intval($manif->nid), FIELD_TYPE_ENTITY_REF) as $periodical) {

	$items[] = $periodical;
      }
      foreach(dss_elc_get_nodes('item', 'field_item_embodies', intval($manif->nid), FIELD_TYPE_ENTITY_REF) as $item) {

	$items[] = $item;
      }
    }
  }

  return $items;
}

/*
 *
 * Use Cases:
 * Agent requests the total number books/periodicals/items loaned to a single person of a certain gender
 * Agent requests the total number of unique titles of books/periodicals/items loaned to a single person of a certain gender
 * Agent requests the total number of unique authors of books/periodicals/items loaned to a single person of a certain gender
 * Agent requests the total number of unique subjects of books/periodicals/items loaned to a single person of a certain gender
 * Agent requests the total number of unique formats of books/periodicals/items loaned to a single person of a certain gender
 *
 */
function dss_elc_metrics_get_indexed_items_loaned($nid, $distinctField) {

  switch($distinctField) {

  case 'title':

      $distinctField = 'field_artifact_title';
      break;

    case 'author':

      $distinctField = 'field_artifact_was_authored_by';
      break;

    case 'subject':

      $distinctField = 'field_item_subject';
      break;

    case 'format':

      $distinctField = 'field_item_format';
      break;
    }

    $index = array();
    $items = array();

    foreach(dss_elc_metrics_get_items_loaned($nid) as $item) {

      if($distinctField == 'field_item_subject') {

	// Unique subjects
	$subjectField = $item->$distinctField;
	
	foreach( $subjectField[$item->language] as $subjectTerm) {
	    
	  if(!in_array($subjectTerm['tid'], $index)) {
	    
	    $index[] = $subjectTerm['tid'];
	    $items[$subjectTerm['tid']] = array($item);
	  } else {
	    
	    $items[$subjectTerm['tid']][] = $item;
	  }
	}
      } elseif($distinctField == 'field_artifact_was_authored_by') {
	
	$authorField = $item->$distinctField;
	$author = dss_elc_get_node('nid', intval($authorField[$item->language]['target_id']), 'person');
	
	if(!in_array($author->nid, $index)) {
	  
	  $index[] = $author->nid;
	  $items[$author->title] = array($item);
	} else {
	  
	  $items[$author->title][] = $item;
	}
      } else {
	
	if(!in_array($item->field_artifact_title[$item->language]->value, $index)) {
	  
	  $index[] = $item->field_artifact_title[$item->language]->value;
	  $items[$item->field_artifact_title[$item->language]->value] = array($item);
	} else {
	  
	  $items[$item->field_artifact_title[$item->language]->value][] = $item;
	}
      }
    }

    //drupal_json_output($items);
    return $items;
}

/*
 *
 * Use Cases:
 * Agent requests the total number of unique titles of books/periodicals/items loaned to a single person of a certain gender
 * Agent requests the total number of unique titles of books/periodicals/items loaned to a single person of a certain occupation
 *
 */
function dss_elc_metrics_get_items_loaned_persons_ajax() {

  $items = array();

  if(array_key_exists('nids', $_POST) && !empty($_POST['nids'])) {

    // Refactor
    if(!isset($_POST[$distinctField])) {

      foreach($_POST['nids'] as $nid) {

	$items[$nid] = dss_elc_metrics_get_items_loaned($nid);
      }
    } else {

      foreach($_POST['nids'] as $nid) {
	
	//$items[$nid] = dss_elc_metrics_get_indexed_items_loaned($nid, $_POST[$distinctField]);
	$items[$nid] = dss_elc_metrics_get_indexed_items_loaned($nid, $_POST[$distinctField]);
      }
    }
  }

  drupal_json_output($items);
}

/**
 * @author griffinj
 * Agent requests the total number of books/periodicals/items by subject loaned to a person of a certain gender
 *
 */

function dss_elc_metrics_get_items_loaned_ajax($nid, $distinctField, $indexField) {

  // Refactor
  if(!isset($distinctField)) {

    //drupal_json_output(dss_elc_metrics_get_items_loaned($nid));
    drupal_json_output(array(
			     'ordinal' => array('domain' => array('subjectA', 'subjectB', 'subjectC'),
						'range' => array(
								 'male' => array(45, 67, 78),
								 'female' => array(54, 76, 87),
								 )
						)
			     ));

  } else {

    drupal_json_output(dss_elc_metrics_get_indexed_items_loaned($nid, $distinctField));
  }
}

function dss_elc_metrics_cache_set($mongo_id, $data, $collection_name='dss_elc_metrics') {

  $collection = mongodb_collection($collection_name);

  if(isset($data)) {

    $doc = array('_id' => $mongo_id,
		 'cid' => $mongo_id,
		 //'created' => REQUEST_TIME,
		 //'expire' => $expire,
		 //'serialized' => !$scalar,
		 //'data' => $scalar ? $data : serialize($data),
		 'data' => $data);

    $collection->save($doc);
  }

  return $data;
  
}

function dss_elc_metrics_cache_get($mongo_id, $collection_name='dss_elc_metrics') {

  $collection = mongodb_collection($collection_name);
  $doc = $collection->findOne(array('_id' => $mongo_id));

  $data = NULL;

  if($doc && isset($doc['data'])) {

    $data = json_decode($doc['data']);
  }

  return $data;
}

function dss_elc_metrics_cache_domains($bundle_u, $field_u, $bundle_v, $field_v) {

  // Cache the loans
  $entity_query = new EntityFieldQuery();
  $entity_query->entityCondition('entity_type', 'node');
  $entity_query->entityCondition('bundle', 'loan');
  //$entity_query->fieldCondition('field_bib_rel_subject', 'target_id', $nids);
  //$entity_query->fieldCondition('field_bib_rel_object', 'target_id', $nids);
  
  $entities = $entity_query->execute();
  $loan_entities = node_load_multiple(array_keys($entities['node']));

  $index = array();
  $json_entity_values = array();

  foreach($loan_entities as $loan_entity) {

    $lang = $loan_entity->language;

    $_object = $loan_entity->field_bib_rel_object->$lang;
    $_object = node_load(intval($_object[0]->target_id));

    //$_object = node_load($loan_entity->field_bib_rel_object_target_id);

    // If this is a manifestation, retrieve the original work
    if($_object->type == 'manifestation') {
      
      $entity_query = new EntityFieldQuery();
      $entity_query->entityCondition('entity_type', 'node');
      $entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
      $entities = $entity_query->execute();
      
      $_object = node_load(array_pop(array_keys($entities['node'])));
    }
    
    // Refactor
    if($field_u != 'field_loan_duration') {
      
      $_field_u = $_object->$field_u;
    }
    
    $_subject = $loan_entity->field_bib_rel_subject->$lang;
    $_subject = node_load(intval($_subject[0]->target_id));
    
    //$_subject = node_load($loan_entity->field_bib_rel_subject_target_id);
    
    /**
     * @abstract Handling for List fields
     * Book/Periodical/Item: field_item_format
     * Human: field_human_gender
     *
     */
    $_field_v = $_subject->$field_v;
    
    // Refactor
    if(empty($_subject->$field_v)) {
      
      $_sample_name = 'Unknown';
    } else {
      
      if($field_v == 'field_human_gender') {
	
	$_field = field_info_field($field_v);
	$_values = list_allowed_values($_field);
	$_sample_name = array_pop($_field_v->$lang);
	$_sample_name = $_values[$_sample_name->value];
      } elseif($field_v == 'field_person_location' ||
	       $field_v == 'field_person_membership') {
	
	$entity_id = array_pop($_field_v->$lang);
	$loan_entity = node_load($entity_id->target_id);
	
	$_sample_name = $loan_entity->title;
      }
    }
    
    // For NULL List field values
    if(!$_sample_name) {
      
      $_sample_name = 'Unknown';
    }
    
    // Term Reference fields
    // Refactor for array
    if($field_u == 'field_human_occupation' ||
       $field_u == 'field_person_type' ||
       $field_u == 'field_item_subject' ||
       $field_u == 'field_artifact_type') {
      
      // For the handling of NULL values
      if(!$_field_u) {
	
	$_field_u = (object) array('und' => array('Unknown'));
      }
      
      foreach($_field_u->$lang as $term) {
	
	//if(!array_key_exists('tid', $term)) {
	if(!property_exists($term, 'tid')) {
	  
	    $domain = 'Unknown';
	} else {
	  
	  $term = taxonomy_term_load($term->tid);
	  $domain = $term->name;
	}
	
	if(!array_key_exists($domain, $json_entity_values)) {
	  
	  $json_entity_values[$domain] = array($_sample_name => 1);	  
	} else {
	  
	  $json_entity_values[$domain][$_sample_name]++;
	}
      }
    } elseif($field_u == 'field_artifact_was_authored_by') { // Entity References

      $_object = node_load(intval($loan_entity->field_bib_rel_object['und'][0]['target_id']));
      $_field_u = $_object->$field_u;

      $entity = node_load(intval($_field_u['und'][0]['target_id']));

      $domain = $loan_entity->field_person_name->$lang;
      $domain = $domain[0]->value;

      // Refactor
      if(!array_key_exists($domain, $json_entity_values)) {
	
	$json_entity_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_entity_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_item_format') { // Refactor

      $_object = node_load(intval($loan_entity->field_bib_rel_object['und'][0]['target_id']));

      if(true) {

	drupal_json_output($_object->$field_u);
	exit(1);
      }

      $_field_u = $_object->$field_u;

      $_field = field_info_field($field_u);
      $_values = list_allowed_values($_field);
      $_domain = array_pop($_field_u->$lang);

      if(true) {

	drupal_json_output($_domain->value);
	exit(1);
      }

      $domain = $_values[$_domain->value];

      //$entity = node_load(intval($_field_u['und'][0]['target_id']));
      
      // For NULL values
      if(!$domain) {
	
	$domain = 'Unknown';
      }
      
      // Refactor
      if(!array_key_exists($domain, $json_entity_values)) {
	
	$json_entity_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_entity_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_loan_duration') { // Loan duration
      
      // Parse from a UNIX timestamp
      $domain = $loan_entity->field_loan_duration_value;
      $date = new DateObject($domain);
      $domain = $date->format('Ymd');
      
      // Refactor
      if(!array_key_exists($domain, $json_entity_values)) {
	
	$json_entity_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_entity_values[$domain][$_sample_name]++;
      }
      
      // Also, set the type of scale to "temporal"
      $scale_type = 'temporal';
    }
  }

  foreach($json_entity_values as $domain => $samples) {

    dss_elc_metrics_cache_set($domain, json_encode($samples));
  }

  dss_elc_metrics_cache_set($field_u, json_encode(array_keys($json_entity_values)));

  return $json_entity_values;
}


function dss_elc_metrics_cache_get_domains($mongo_id) {

  // REFACTOR
  // This should be a Document structure WITHOUT foreign keys
  $domain_names = dss_elc_metrics_cache_get($mongo_id);

  if(!isset($domain_names)) {

    return NULL;
  }

  $domains = array();
  foreach($domain_names as $domain_name) {

    $domains[$domain_name] = dss_elc_metrics_cache_get($domain_name);
  }

  return $domains;
}

function dss_elc_metrics_cache($mongo_id, $collection_name='dss_elc_metrics', $data=NULL) {

  $collection = mongodb_collection($collection_name);

  $doc = $collection->findOne(array('_id' => $mongo_id));

  if(isset($data)) {

    if(!$doc || !isset($doc['data'])) {

      $doc = array('_id' => $mongo_id,
		   'cid' => $mongo_id,
		   //'created' => REQUEST_TIME,
		   //'expire' => $expire,
		   //'serialized' => !$scalar,
		   //'data' => $scalar ? $data : serialize($data),
		   'data' => $data);

      $collection->save($doc);
    } else {
      
      $data = $data['data'];
    }

  }

  return $data;
}

/**
 * @abstract
 * Implementing a separate MongoDB cache for the Objects generated
 *
 */
function dss_elc_metrics_cache_call($params, $callback, $force_update=FALSE, $collection_name='dss_elc_metrics') {

  $collection = mongodb_collection($collection_name);
  $mongo_id = json_encode($params);

  $data = $collection->findOne(array('_id' => $mongo_id));

  drupal_json_output(call_user_func_array($callback, $params));

  if($force_update || (!$data || !isset($data['data']))) {

    $object = call_user_func_array($callback, $params);

    $doc = array('_id' => $mongo_id,
		 'cid' => $mongo_id,
		 //'created' => REQUEST_TIME,
		 //'expire' => $expire,
		 //'serialized' => !$scalar,
		 //'data' => $scalar ? $data : serialize($data),
		 'data' => $object);

    $collection->save($doc);
  } else {

    $data = $data['data'];
  }

  return $data;
}

function dss_elc_metrics_domain($node, $domain_field) {

  /**
   * For loans, these can be analyzed in relation to the following:
   * - Shareholder Attributes
   *   - Name
   *   - Gender
   * - Representative Attributes
   *   - Name
   *   - Gender
   * - Checkout Date of the Loan
   * - Item Attributes
   *   - Title
   *   - Subject
   *   - Type
   *   - Author Attributes
   *     - Name
   *     - Gender
   */

  if($domain_field == 'quantity') {

    $domain = $node[0] . 's';
  } else {

    if($node->type == 'loan') {

      // Shareholder attributes
      
      // Representative attributes

      // Item attributes

      // Author attributes
    } elseif($node->type == 'item' or
	     $node->type == 'book' or
	     $node->type == 'periodical') {

    } elseif($node->type == 'human') {
      
    }
  }

  return $domain;
}

function dss_elc_metrics_related_nodes($node, $sample_field, $group) {

  // Perform the pseudo JOIN
  // Retrieve the related loan nodes
  //! @todo Abstract in order to support loans, personal relationships, and deeply nested relationships (e. g. total items loaned to persons with families of a certain size)
  //! @todo Refactor using db_select().

  //if(in_array($sample_field, array('field_human_gender'))) {
  if(true) {

    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'loan')
      ->propertyCondition('status', NODE_PUBLISHED);

    if($node->type == 'item' or
       $node->type == 'book' or
       $node->type == 'periodical') {

      // Loans are linked to the Manifestation Node
      $manifest_nid = $node->field_item_embodies[$node->language][0]['target_id'];
      //$query->fieldCondition('field_bib_rel_object', 'target_id', $manifest_nid);
    } elseif($node->type == 'human') {

      $query->fieldCondition('field_bib_rel_subject', 'target_id', $node->nid);
      $query->fieldCondition('field_loan_shareholder', 'target_id', $node->nid);
    }

    //$query->range(0, 10);
    //$query->addMetaData('account', user_load(1)); // Run the query as user 1.
    $result = $query->execute();

    $relationships = array();
    if(isset($result['node'])) {
      
      $nids = array_keys($result['node']);
      $relationships = entity_load('node', $nids);
    }
  }

  $related_nodes = array();

  if($node->type == 'loan') {

  } elseif($node->type == 'item' or
	   $node->type == 'book' or
	   $node->type == 'periodical') {

    /*
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      //->entityCondition('bundle', array('item', 'book', 'periodical'), 'IN')
      ->propertyCondition('status', NODE_PUBLISHED);

    if(true) {

      print $sample_field;
      $query->fieldCondition($sample_field, 'value', );
    }

    //->fieldOrderBy('field_loan_duration', 'value', 'ASC')
    //->addMetaData('account', user_load(1)); // Run the query as user 1.
    $query->range(0, 10);

    $result = $query->execute();
    */

    //print_r($relationships);
    // Retrieve the nodes related to $node using the $relationships
    foreach($relationships as $rel) {

      //! @todo Refactor
      $entity_reference_field = 'field_bib_rel_object';
    
      // Retrieve the related values
      $related_values = $rel->$entity_reference_field[$rel->language];
      foreach($related_values as $rel_val) {

	if(in_array($entity_reference_field, array('field_bib_rel_object',
						   'field_bib_rel_subject',
						   'field_loan_shareholder'))) {

	  // Retrieve the related node if this is a related value
	  $related_node = node_load($rel_val);

	  // Generate the sample using the sample field
	  $sample = $related_node->$sample_field[$related_node->language][0]['value'];
	} else {

	  // Generate the sample using the related value itself
	  $sample = $rel_val;
	}

	// Set the value
	if(!array_key_exists($sample, $related_nodes)) {
	  
	  $related_nodes[$sample] = 1;
	} else {
	  
	  $related_nodes[$sample]++;
	}
      }
    }

  } elseif($node->type == 'human') {

    /*
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'human')
      ->propertyCondition('status', NODE_PUBLISHED)
      //->fieldOrderBy('field_loan_duration', 'value', 'ASC')
      //->addMetaData('account', user_load(1)); // Run the query as user 1.
      ->range(0, 10);

    $result = $query->execute();
    */
  }

  /*
  $nodes = array();
  if(isset($result['node'])) {
    
    $nids = array_keys($result['node']);
    $nodes = entity_load('node', $nids);
  }
  */

  //print_r($nodes);
  //exit(1);

  return $related_nodes;
}

function dss_elc_metrics_sample($node, $sample_field) {

  //print $sample_field;
  //print_r($node->type);

  $field_sample_map = array('field_human_gender' => 'field_human_gender');
  $node_field = $field_sample_map[$sample_field];

  if(empty($node->{$sample_field})) {

    $sample = 'Unknown';
  } else {

    $sample = $node->{$sample_field}[$node->language][0]['value'];
  }

  if($node->type == 'loan') {

    // Shareholder attributes
      
    // Representative attributes

    // Item attributes

    // Author attributes
  } elseif($node->type == 'item' or
	   $node->type == 'book' or
	   $node->type == 'periodical') {

  } elseif($node->type == 'human') {

    /*
    $field_sample_map = array('field_human_gender' => 'field_human_gender');
    $node_field = $field_sample_map[$sample_field];
    if(empty($node->{$sample_field})) {

      $sample = 'Unknown';
    } else {

      $sample = $node->{$sample_field}[$node->language][0]['value'];
    }
    */
  }

  return $sample;
}

//function dss_elc_metrics_db_parse($records, $bundles, $domain_field, $sample, $sample_field, $metric = 'sum') {
//function dss_elc_metrics_db_parse($records, $bundles, $domain_field, $sample_field, $metric = 'sum') {
function dss_elc_metrics_db_parse($records, $sample_bundles, $sample_field, $domain_bundles, $domain_field, $metric = 'sum') {

  $data = array();

  foreach($samples as $sample) {

    
  }

  // Case: Total number of items loaned by gender of human borrower
  // For each item...
  foreach($records as $node) {

    // ...retrieve the x-axis value (e. g. "Male", "Female"...)
    $sample = dss_elc_metrics_sample($node, $sample_field);

    //! @todo Refactor
    $group = 'Borrowers';

    //print $node->nid . "\n";

    $related_nodes = dss_elc_metrics_related_nodes($node, $sample_field, $group);

    // ...retrieve the y-axis value (e. g. 0 items loaned, 1 item loaned...)
    //$domain = dss_elc_metrics_domain($domain_bundles, $domain_field);

    // Calculate the y-axis value
    foreach($related_nodes as $sample => $related_node) {

      // Initialize the new domain if it does not exist
      if(!array_key_exists($domain, $data)) {

	$data[$domain] = array();
      }

      // Perform the operation for the sample
      if($metric == 'amean') {

	//! @todo Implement
      } else { // For simple summation and all other cases

	if(!array_key_exists($sample, $data[$domain])) {

	  $data[$domain] = array($sample => 1);
	} else {

	  $data[$domain][$sample]++;
	}
      }
    }
  }

  // For NVD3 multi-bar chart
  /*
  array(array('key' => 'sample1',
	      'values' => array( array('x' => 0,
				       'y' => 123)  )),
	array('key' => 'sample2',
	      'values' => array()),
	      )
	)
  */
    
  /**
   * For loans, these can be analyzed in relation to the following:
   * - Shareholder Attributes
   *   - Name
   *   - Gender
   * - Representative Attributes
   *   - Name
   *   - Gender
   * - Checkout Date of the Loan
   * - Item Attributes
   *   - Title
   *   - Subject
   *   - Type
   *   - Author Attributes
   *     - Name
   *     - Gender
   */
  if(in_array('loan', $bundles)) {

  } elseif(in_array('item', $bundles)) {

  } elseif(in_array('human', $bundles)) {

  }

  foreach($records as $record) {

    //print_r($record);    
  }

  if(true) {

    return;
  }

  if(in_array('loan', $bundles)) {

    //response
    foreach($records as $record) {

      $_object = node_load($record->field_bib_rel_object_target_id);

      // If this is a manifestation, retrieve the original work
      if($_object->type == 'manifestation') {

	$entity_query = new EntityFieldQuery();
	$entity_query->entityCondition('entity_type', 'node');
	$entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
	$entities = $entity_query->execute();

	$_object = node_load(array_pop(array_keys($entities['node'])));
      }

      // Refactor
      if($field_u != 'field_loan_duration') {

	$_field_u = $_object->$field_u;
      }

      $_subject = node_load($record->field_bib_rel_subject_target_id);

      /**
       * @note Handling for List fields
       * Book/Periodical/Item: field_item_format
       * Human: field_human_gender
       *
       */
      $_field_v = $_subject->$field_v;
      
      // Refactor
      if(empty($_subject->$field_v)) {
	
	$_sample_name = 'Unknown';
      } else {
      
	if($field_v == 'field_human_gender') {
	  
	  $_field = field_info_field($field_v);
	  $_values = list_allowed_values($_field);
	  $_sample_name = array_pop($_field_v['und']);
	  $_sample_name = $_values[$_sample_name['value']];
	} elseif($field_v == 'field_person_location' ||
		 $field_v == 'field_person_membership') {
	
	  $entity_id = array_pop($_field_v['und']);
	  $entity = node_load($entity_id['target_id']);
	
	  $_sample_name = $entity->title;
	}
      }
      
      // For NULL List field values
      if(!$_sample_name) {
	
	$_sample_name = 'Unknown';
      }
      
      // Term Reference fields
      // Refactor for array
      if($field_u == 'field_human_occupation' ||
	 $field_u == 'field_person_type' ||
	 $field_u == 'field_item_subject' ||
	 $field_u == 'field_artifact_type') {
      
      // For the handling of NULL values
      if(!$_field_u) {
	
	$_field_u = array('und' => array('Unknown'));
      }
      
      foreach($_field_u['und'] as $term) {
	  
	if(!array_key_exists('tid', $term)) {
	  
	  $domain = 'Unknown';
	} else {

	  $term = taxonomy_term_load($term['tid']);
	  $domain = $term->name;
	}

	if(!array_key_exists($domain, $json_record_values)) {

	  $json_record_values[$domain] = array($_sample_name => 1);	  
	} else {
	  
	  $json_record_values[$domain][$_sample_name]++;
	}
      }
    } elseif($field_u == 'field_artifact_was_authored_by') { // Entity References
      
      $entity_id = array_pop($_field_u['und']);
      $entity = node_load($entity_id['target_id']);
      
      $domain = $entity->field_person_name['und'][0]['value'];
      
      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_item_format') { // Refactor

      $_field = field_info_field($field_u);
      $_values = list_allowed_values($_field);
      $_domain = array_pop($_field_u['und']);
      $domain = $_values[$_domain['value']];

      // For NULL values
      if(!$domain) {

	$domain = 'Unknown';
      }

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_loan_duration') { // Loan duration

      // Parse from a UNIX timestamp
      $domain = $record->field_loan_duration_value;
      $date = new DateObject($domain);
      $domain = $date->format('Ymd');

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }

      // Also, set the type of scale to "temporal"
      $scale_type = 'temporal';
    }
    }
  }
}

function dss_elc_metrics_db_query($bundles) {

  // Retrieve all bundles from the ELC database sorted by the values for the field
  $query = db_select('node', 'n');
  $result = array();
  $query = new EntityFieldQuery();

  if(in_array('loan', $bundles)) {
  //if(true) {
  //if(false) {

    /**
     * For loans, these can be analyzed in relation to the following:
     * - Shareholder Attributes
     *   - Name
     *   - Gender
     * - Representative Attributes
     *   - Name
     *   - Gender
     * - Checkout Date of the Loan
     * - Item Attributes
     *   - Title
     *   - Subject
     *   - Type
     *   - Author Attributes
     *     - Name
     *     - Gender
     */
    /*
    $query->condition('n.type', 'loan', '=');
    $query->join("field_data_field_bib_rel_subject", 'bib_rel_subject', 'bib_rel_subject.entity_id=n.nid'); // JOIN on all Representative NID's
    $query->join("field_data_field_loan_shareholder", 'shareholder', 'shareholder.entity_id=n.nid'); // JOIN on all Shareholder NID's
    $query->join("field_data_field_loan_duration", 'loan_duration', 'loan_duration.entity_id=n.nid'); // JOIN on the duration of the loan
    $query->join("field_data_field_bib_rel_object", 'bib_rel_object', 'bib_rel_subject.entity_id=n.nid'); // JOIN on all Item/Book/Periodical NID's

    $query->fields('n');

    $query->fields('bib_rel_subject', array('field_bib_rel_subject_target_id'));
    $query->fields('shareholder', array('field_loan_shareholder_target_id'));
    $query->fields('loan_duration', array('field_loan_duration_value', 'field_loan_duration_value2'));
    $query->fields('bib_rel_object', array('field_bib_rel_object_target_id'));
    */


    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'loan')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldOrderBy('field_loan_duration', 'value', 'ASC')
      //->addMetaData('account', user_load(1)); // Run the query as user 1.
      ->range(0, 500);

    $result = $query->execute();
  } elseif(in_array('item', $bundles)) {
    //} elseif(true) {

    /**
     * For items, these can be analyzed in relation to the following:
     * - Title
     * - Subject
     * - Type
     * - Manifestation
     * - Author Attributes
     *   - Name
     *   - Gender
     * - Loan Attributes
     *   - Shareholder Attributes
     *     - Name
     *     - Gender
     *   - Representative Attributes
     *     - Name
     *     - Gender
     *   - Checkout Date of the Loan     
     */

    /*
    $query->condition('n.type', 'item', '=');

    $query->join("field_data_field_artifact_title", 'artifact_title', 'artifact_title.entity_id=n.nid'); // JOIN on the title of the item

    $query->join("field_data_field_item_embodies", 'item_embodies', 'item_embodies.entity_id=n.nid'); // JOIN on all manifestation NID's
    $query->join("field_data_field_artifact_was_authored_by", 'artifact_was_authored_by', 'artifact_was_authored_by.entity_id=n.nid'); // JOIN on all authors NID's
    
    $query->fields('n');

    $query->fields('artifact_title', array('field_artifact_title_value'));
    $query->fields('item_embodies', array('field_item_embodies_target_id'));
    $query->fields('artifact_was_authored_by', array('field_artifact_was_authored_by_target_id'));
    */

    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', array('item', 'book', 'periodical'), 'IN')
      ->propertyCondition('status', NODE_PUBLISHED)
      //->addMetaData('account', user_load(1)); // Run the query as user 1.
      ->range(0, 500);
      //->range(0, 10);

    $result = $query->execute();
  } elseif(in_array('human', $bundles)) {

    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'human')
      ->propertyCondition('status', NODE_PUBLISHED)
      //->addMetaData('account', user_load(1)); // Run the query as user 1.
      //->range(0, 500);
      ->range(0, 10);

    $result = $query->execute();
  }

  /**
   * For performance reasons, single queries should be limited to 500
   */

  /*
  print_r($query);
  $result = $query->execute();
  print_r($result->fetchAssoc());

  return $result;
  */

  $nodes = array();
  if(isset($result['node'])) {
    
    $nids = array_keys($result['node']);
    $nodes = entity_load('node', $nids);
  }

  return $nodes;
}

/**
 * Retrieve the total number of records for each field
 * @todo Abstract the metrics for each axis (e. g. total number of items against average number of loans)
 *
 */
function dss_elc_metrics_bivariate_summation($bundle_u, $field_u, $bundle_v, $field_v) {

  $bundles_u = $bundle_u == 'item' ? array('item','book','periodical') : array($bundle_u);
  $bundles_v = $bundle_v == 'item' ? array('item','book','periodical') : array($bundle_v);

  $bundle = $bundle_u;
  $bundles = $bundles_u;

  // Connect and attempt to retrieve the samples from the cache
  list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('metrics_bivariate_cache_sum');
  $mongo_key = 'metrics_bivariate_cache_sum_' . implode('_', array($bundle_u, $field_u, $bundle_v, $field_v));

  // If the samples have been cached, retrieve them
  $cached = $mongo_collection->findOne(array('query' => $mongo_key));
  if($cached) {

    $connections = $mongo->getConnections();

    // Uncertain as to why this is necessary
    foreach ( $connections as $conn ) {
      
      $closed = $mongo->close( $conn['hash'] );
    }
    return $cached['data'];
  }

  $data = array();

  //$domain = $field;

  //$query = array();

  // Anomalous cases
  //! @todo To be implemented
  if($field_u == 'related_loans_duration_elapsed') {

    // For more complex cases in which relationships beyond the initial loans are desired
  } else {

    // Query Solr and retrieve the faceted values for the field
    //$query = array('+' . $field . ':[* TO *]');
    $query = array();
    $data = array();

    $field_solr_map = array('field_artifact_was_authored_by' => 'sm_field_artifact_was_authored_b',
			    'field_item_subject' => 'sm_vid_Item_Subjects',
			    'field_item_format' => 'bundle_name',

			    'field_human_gender' => 'bs_field_gender',
			    'field_person_type' => 'sm_vid_Person_Types',

			    'field_bib_rel_subject' => 'sm_field_bib_rel_subject',
			    'field_loan_shareholder' => 'sm_field_loan_shareholder',
			    'field_bib_rel_object' => 'sm_field_bib_rel_object',
			    'field_loan_duration_value_0' => 'is_field_loan_duration_value'
			    );

    $entity_reference_fields = array('sm_field_artifact_was_authored_b' => array('human'),

				     'sm_field_bib_rel_subject' => array('human'),
				     'sm_field_loan_shareholder' => array('human'),
				     'sm_field_bib_rel_object' => array('item', 'book', 'periodical')
				     );

    $solr_field_sample_label_map = array('sm_field_artifact_was_authored_b' => 'Author',
					 'sm_vid_Item_Subjects' => 'Subject',
					 'bundle_name' => 'Type',

					 'bs_field_gender' => 'Gender',
					 'sm_vid_Person_Types' => 'Type');

    $field_u = $field_solr_map[$field_u];
    $field_v = $field_solr_map[$field_v];

    $data = array();
    $query = array();

    // Iterate through all loans

    // ...and if this data set hasn't been cached, prepare for delayed response
    set_time_limit(540 * 4);

    list($query, $results) = dss_elc_metrics_solr_query(array('loan'), $query, 1000000);

    $loans = $results->response->docs;
    $samples = array();

    foreach($loans as $loan_doc) {

      $domains = array();
      $data;

      $query = array();
      
      // This should be iterative for multiple volumes borrowed during a single loan
      $manifest_nid = $loan_doc->sm_field_bib_rel_object;
      $query[] = 'sm_field_item_embodies:"' . $manifest_nid[0] . '"';
      //list($query, $results) = dss_elc_metrics_solr_query($bundles_v, $query, 1000000);
      list($query, $results) = dss_elc_metrics_solr_query(array('item', 'book', 'periodical'), $query, 1);
      $item_doc = $results->response->docs[0];
      
      $human_docs = array();
      
      // Retrieve the related humans
      foreach(array('sm_field_bib_rel_subject',
		    'sm_field_loan_shareholder') as $human_reference_field) {
	
	// This should be iterative for multiple volumes borrowed during a single loan
	$human_nid = $loan_doc->$human_reference_field;
	preg_match('/node\:(\d+)/', $human_nid[0], $m);
	$human_nid = intval($m[1]);
	
	$query = array();
	$query[] = 'entity_id:"' . $human_nid . '"';
	
	list($query, $results) = dss_elc_metrics_solr_query(array('human'), $query, 1);
	
	$human_field = $field_v;
	$docs = $results->response->docs;
	
	// This assumes that there is one (and only one) Shareholder or Representative specified within a Loan record
	if(!empty($docs)) {
	  
	  $human_docs[] = $docs[0];
	}
      }
      
      //! @todo Refactor
      if($bundle_v == 'item') {
	
	$domain = is_array($item_doc->$field_v) ? $item_doc->$field_v : array($item_doc->$field_v);
	
	if(empty($domain) or empty($domain[0])) {
	  
	  $domains[] = 'Unknown';
	} elseif(array_key_exists($field_v, $entity_reference_fields)) {
	  
	  preg_match('/node\:(\d+)/', $domain[0], $m);
	  $rel_nid = intval($m[1]);
	  
	  // Retrieve the label for entity reference fields
	  $query = array();
	  $query[] = 'entity_id:' . $rel_nid;
	  
	  $rel_bundles = $entity_reference_fields[$field_v];
	  
	  list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1);
	  
	  $rel_docs = $results->response->docs;
	  
	  if(empty($rel_docs)) {
	    
	    $domains[] = 'Unknown';
	  } else {
	    
	    $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	  }
	} else {
	  
	  $domains[] = $domain[0];
	}
	
      } elseif($bundle_v == 'human') {
	
	$human_field = $field_v;
	
	// As there are multiple Human Nodes related to any given Loan Node...
	foreach($human_docs as $human_doc) {
	  
	  $human_doc = $results->response->docs[0];
	  
	  $domain = is_array($human_doc->$field_v) ? $human_doc->$field_v : array($human_doc->$field_v);
	  
	  if(empty($domain) or empty($domain[0])) {
	    
	    if(array_search('Unknown', $domains) === FALSE) {
	      
	      $domains[] = 'Unknown';
	    }
	  } elseif(array_key_exists($field_v, $entity_reference_fields)) {
	    
	    preg_match('/node\:(\d+)/', $domain[0], $m);
	    $rel_nid = intval($m[1]);
	    
	    // Retrieve the label for entity reference fields
	    $query = array();
	    $query[] = 'entity_id:' . $rel_nid;
	    
	    $rel_bundles = $entity_reference_fields[$field_v];
	    
	    list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1);
	    
	    $rel_docs = $results->response->docs;
	    
	    if(empty($rel_docs)) {
	      
	      $domains[] = 'Unknown';
	    } else {
	      
	      $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	    }
	  } else {
	    
	    $domains[] = $domain[0];
	  }
	}
      } elseif($bundle_v == 'loan') {

	$domain = is_array($loan_doc->$field_v) ? $loan_doc->$field_v : array($loan_doc->$field_v);
	
	if(empty($domain) or empty($domain[0])) {
	  
	  $domains[] = 'Unknown';
	} elseif(array_key_exists($field_v, $entity_reference_fields)) {
	  
	  preg_match('/node\:(\d+)/', $domain[0], $m);
	  $rel_nid = intval($m[1]);
	  
	  // Retrieve the label for entity reference fields
	  $query = array();
	  $query[] = 'entity_id:' . $rel_nid;
	  
	  $rel_bundles = $entity_reference_fields[$field_v];
	  
	  // Only retrieve one document
	  list($query, $results) = dss_elc_metrics_solr_query($rel_bundles, $query, 1);
	  
	  $rel_docs = $results->response->docs;
	  
	  if(empty($rel_docs)) {
	    
	    $domains[] = 'Unknown';
	  } else {

	    $domains[] = empty($rel_docs[0]->label) ? 'Unknown' : $rel_docs[0]->label;
	  }
	} else {
	  
	  $domains[] = $domain[0];
	}
      }
      
      
      /**
       * Generate the data for the (grouped) samples and link these points to the output
       *
       */
      
      $groups = dss_elc_metrics_samples($bundle_u, $field_u);
      
      if($bundle_u == 'item') {
	
	if( array_key_exists($field_u, $entity_reference_fields) ) {
	  
	  // Retrieve the label for entity reference fields
	  $query = array();
	  $entity_ids = $item_doc->$field_u;

	  if(empty($entity_ids)) {

	    $range_docs = $results->response->docs;
	  } else {

	    $entity_id = array_shift($entity_ids);
	  
	    preg_match('/node\:(\d+)/', $entity_id, $m);
	    $nid = intval($m[1]);
	    $query[] = 'entity_id:' . $nid;
	  
	    $range_bundles = $entity_reference_fields[$field_u];
	  
	    list($query, $results) = dss_elc_metrics_solr_query($range_bundles, $query, 1);
	  
	    $range_docs = $results->response->docs;
	  }
	  
	  if(empty($range_docs)) {
	    
	    $field_u_value = 'Unknown';
	  } else {
	    
	    $field_u_value = empty($range_docs[0]->label) ? 'Unknown' : $range_docs[0]->label;
	  }
	} else {
	  
	  $field_u_value = is_array($item_doc->$field_u) ? array_shift($item_doc->$field_u) : $item_doc->$field_u;
	  if(empty($field_u_value)) {

	    $field_u_value = 'Unknown';
	  }
	}
	
	$field_u_value = trim($field_u_value);
	
	$label = array_key_exists($field_u_value, $groups) ? $field_u_value : 'Unknown';
	
	if($field_u_value == $label or
	   ($label == 'Unknown' and !array_key_exists($field_u_value, $groups))) {
	  
	  if(!array_key_exists($label, $samples)) {
	    
	    $samples[$label] = array();
	  }
	  
	  foreach($domains as $domain) {
	    
	    if(!array_key_exists($domain, $samples[$label])) {
	      
	      $samples[$label][$domain] = 1;
	    } else {
	      
	      $samples[$label][$domain]++;
	    }
	  }
	}
      } elseif($bundle_u == 'loan') { // For loans
	
	if( array_key_exists($field_u, $entity_reference_fields) ) {
	  
	  // Retrieve the label for entity reference fields
	  $query = array();
	  $entity_ids = $loan_doc->$field_u;

	  if(empty($entity_ids)) {

	    $range_docs = array();
	  } else {

	    $entity_id = array_shift($entity_ids);
	    
	    preg_match('/node\:(\d+)/', $entity_id, $m);
	    $nid = intval($m[1]);
	    $query[] = 'entity_id:' . $nid;
	    
	    $range_bundles = $entity_reference_fields[$field_u];
	    
	    list($query, $results) = dss_elc_metrics_solr_query($range_bundles, $query, 1);
	    
	    $range_docs = $results->response->docs;
	  }
	  
	  if(empty($range_docs)) {
	    
	    $field_u_value = 'Unknown';
	  } else {
	    
	    $field_u_value = empty($range_docs[0]->label) ? 'Unknown' : $range_docs[0]->label;
	  }
	} else {
	  
	  $field_u_value = $loan_doc->$field_u;
	}
	
	$label = array_key_exists($field_u_value, $groups) ? $field_u_value : 'Unknown';
	
	if($field_u_value == $label or
	   //$loan_doc->$field_u == $label or
	   ($label == 'Unknown' and !array_key_exists($field_u_value, $groups))
	   //($label == 'Unknown' and !array_key_exists($loan_doc->$field_u, $groups))
	   ) {
	  
	  if(!array_key_exists($label, $samples)) {
	    
	    $samples[$label] = array();
	  }
	  
	  foreach($domains as $domain) {
	    
	    if(!array_key_exists($domain, $samples[$label])) {
	      
	      $samples[$label][$domain] = 1;
	    } else {
	      
	      $samples[$label][$domain]++;
	    }
	  }
	}
      } elseif($bundle_u == 'human') { // For humans
	
	foreach($human_docs as $human_doc) {
	  
	  $field_u_value = is_array($human_doc->$field_u) ? array_shift($human_doc->$field_u) : $human_doc->$field_u;
	  
	  $label = array_key_exists($field_u_value, $groups) ? $field_u_value : 'Unknown';
	  
	  if($field_u_value == $label or
	     ($label == 'Unknown' and !array_key_exists($field_u_value, $groups))) {
	    
	    if(!array_key_exists($label, $samples)) {
	      
	      $samples[$label] = array();
	    }
	    
	    foreach($domains as $domain) {
	      
	      if(!array_key_exists($domain, $samples[$label])) {
		
		$samples[$label][$domain] = 1;
	      } else {
		
		$samples[$label][$domain]++;
	      }
	    }
	  }
	}
      }
    }

    $mongo_collection->update(array('query' => $mongo_key),
			      array('query' => $mongo_key,
				    'data' => $samples),
			      array('upsert' => TRUE));

    // Uncertain as to why this is necessary
    foreach ( $connections as $conn ) {
      
      $closed = $mongo->close( $conn['hash'] );
    }
    
    return $samples;
  }
}

function dss_elc_metrics_bivariate_summation_deprecated($bundle_u, $field_u, $bundle_v, $field_v) {

  if(true) {

    //! @todo Refactor

    if($bundle_v == 'human') {

      $query[] = '(sm_vid_Person_Types:Shareholder OR sm_vid_Person_Types:Representative)';
    }

    $rows = 1000000;

    //$facets = array('facet.field' => $field);
    list($query, $results) = dss_elc_metrics_solr_query($bundles_v, $query, $rows);

    $docs = $results->response->docs;

    print_r($docs[0]);
    exit(1);

    // For each item...
    foreach($docs as $doc) {

      $query = array();
      //$query[] = 'sm_field_bib_rel_object:"node:' . $doc->entity_id . '"';
      
      // For each doc, retrieve the loan
      list($query, $results) = dss_elc_metrics_solr_query(array('loan'), $query, 1000000);

      $loans = $results->response->docs;
      foreach($loans as $loan_doc) {

	print_r($loan_doc);
	exit(1);

	$domain = '';
	$data;

	if(true) {

	  $manifest_nid = $loan_doc->sm_field_bib_rel_object;
	  preg_match('/node\:(\d+)/', $manifest_nid[0], $m);

	  $manifest_nid = intval($m[1]);

	  $query = array();
	  $query[] = 'entity_id:' . $manifest_nid;

	  list($query, $results) = dss_elc_metrics_solr_query(array('manifestation'), $query, 1000000);

	  $manifest_doc = $results->response->docs[0];
	  $item_nid = $manifest_doc->sm_field_item_embodies;
	  preg_match('/node\:(\d+)/', $item_nid[0], $m);

	  $item_nid = intval($m[1]);

	  $query = array();
	  $query[] = 'entity_id:' . $item_nid;

	  list($query, $results) = dss_elc_metrics_solr_query($bundles_v, $query, 1000000);
	  $item_doc = $results->response->docs[0];

	  print_r($item_doc);

	  //$data[];
	}

	exit(1);
      }
    }

    exit(1);
    $num_found = $results->response->numFound;

    // Attempt to retrieve information pertaining to the field
    $info = field_info_instance('node', $field_u, $bundle);
  }

  return $data;
}

function dss_elc_metrics_solr_parse() {

  
}

/**
 * Retrieve the samples (i. e. facets and associated quantities) for the metrics
 * @todo Integrate with the MongoDB
 *
 */
function dss_elc_metrics_samples($bundle, $field) {

  // Connect and attempt to retrieve the samples from the cache
  list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('metrics_samples_cache');

  $mongo_key = 'metrics_samples_cache' . '_' . implode('_', array($bundle, $field));

  // If the samples have been cached, retrieve them
  $cached_samples = $mongo_collection->findOne(array('sample' => $mongo_key));
  if($cached_samples) {

    return $cached_samples['data'];
  }

  $bundles = $bundle == 'item' ? array('item','book','periodical') : array($bundle);

  $entity_reference_fields = array('sm_field_artifact_was_authored_b',
				   
				   'sm_field_bib_rel_subject',
				   'sm_field_bib_rel_object',
				   'sm_field_loan_shareholder'
				   );

  $entity_reference_bundles = array('sm_field_artifact_was_authored_b' => array('human'),

				    'sm_field_bib_rel_subject' => array('human'),
				    'sm_field_bib_rel_object' => array('item', 'book', 'periodical'),
				    'sm_field_loan_shareholder' => array('human')
				    );

  //$tid_fields = array('field_person_type');
  $solr_facet_field_map = array('field_person_type' => 'sm_vid_Person_Types',
				//'sm_field_bib_rel_subject' => 'sm_vid_Subjects',
				);
  $solr_facet_field_include = array('bundle_name' => array('Book',
							   'Periodical',
							   'Item'));

  $samples = array('Unknown' => 0);
  $num_faceted = 0;

  if($field == 'related_manifestation_title') {

    //! @todo To be implemented
  } else {

    // Query Solr and retrieve the faceted values for the field
    //$query = array('+' . $field . ':[* TO *]');
    $query = array();
    if($bundle == 'human') {

      $query[] = '(sm_vid_Person_Types:Shareholder OR sm_vid_Person_Types:Representative)';
    }

    $rows = 1000000;

    if(array_key_exists($field, $solr_facet_field_map)) {

      $faceting_field = $solr_facet_field_map[$field];
    } else {

      $faceting_field = $field;
      //$faceting_field = 'entity_id';
    }

    $facets = array('facet.field' => array($faceting_field));

    list($query, $results) = dss_elc_metrics_solr_query($bundles, $query, $rows, TRUE, $facets);

    $num_found = $results->response->numFound;

    $facet_fields = $results->facet_counts->facet_fields;

    foreach($facet_fields as $key => $facet_field) {

      $facet_field_value = (array) $facet_field;

      if(!empty($facet_field_value)) {

	foreach($facet_field as $sample => $quantity) {

	  if(array_key_exists($faceting_field, $solr_facet_field_include) and
	     !in_array($sample, $solr_facet_field_include[$faceting_field])) {
	    
	    continue;
	  }

	  // For entity reference fields...
	  if(in_array($field, $entity_reference_fields)) {
	    
	    preg_match('/node\:(\d+)/', $sample, $m);
	    $nid = $m[1];

	    // Query Solr for the related Node
	    $sample_node_query = array();
	    $sample_node_query[] = 'entity_id:' . $nid;
	    $sample_bundles = $entity_reference_bundles[$field];

	    list($sample_node_query, $sample_node_results) = dss_elc_metrics_solr_query($sample_bundles, $sample_node_query, 1);

	    $sample_docs = $sample_node_results->response->docs;

	    if(empty($sample_docs)) {

	      $sample = 'Unknown';
	    } else {

	      $sample_doc = $sample_node_results->response->docs[0];
	      $sample = empty($sample_doc->label) ? 'Unknown' : $sample_doc->label;
	    }
	  }

	  $sample = trim($sample);

	  $samples[$sample] = $quantity;
	  $num_faceted += $quantity;
	}
      } else {

	$samples['Unknown']++;
      }
    }
  }

  // Needs to be extended for one-to-many relationships
  if($samples['Unknown'] == 0 and $num_faceted < $num_found) {

    $samples['Unknown'] = $num_found - $num_faceted;
  }

  $mongo_collection->update(array('sample' => $mongo_key),
			    array('sample' => $mongo_key,
				  'data' => $samples),
			    array('upsert' => TRUE));

  return $samples;
}

/**
 * @author griffinj
 * Retrieve the data for the bivariate relationships
 *
 */
function _dss_elc_metrics_bivariate($bundle_u, $field_u, $bundle_v, $field_v, $chart = 'bar', $metric_u = 'sum', $metric_v = 'sum') {

  /**
   * @todo Integrate MongoDB caching
   *
   */
  $mongo_id = 'quantitative';
  $collection_name = 'dss_elc_metrics_loans';

  // Cache the domains
  $mongo_id = $field_u;
  $collection_name = 'dss_elc_metrics_loans';

  //$domains = dss_elc_metrics_cache_get($mongo_id, $collection_name);

  /** @todo Integrate MongoDB caching */
  /*
  $domains = dss_elc_metrics_cache_get_domains($field_u);

  if(!isset($domains)) {
    
    $domains = dss_elc_metrics_cache_domains($bundle_u, $field_u, $bundle_v, $field_v);
  }
  */

  $metrics = array();

  // Apply a linear transform for D3
  $output = array();

  foreach($domains as $domain => $samples) {

    $sample_values = array();
    
    foreach($samples as $sample => $qty) {
      
      $sample_values[] = array('sample' => $sample,
			       'value' => $qty);

      /**
       * @todo Integrate with a remote service call to the QAS
       *
       */
      /*
      $metrics[$sample] = array('sample' => $sample,
				'aMean' => mt_rand() / mt_getrandmax(),
				'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				'mode' => mt_rand() / mt_getrandmax(),
				'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				'distribution' => 'Poisson');
      */
    }

    // Refactor
    if($field_u == 'field_loan_duration') {
     
      // Work-around
      $output[] = array('domain' => (string) $domain,
			'values' => $sample_values);
    } else {

      $output[] = array('domain' => $domain,
			'values' => $sample_values);
    }
  }

  /**
   * Generate the labels
   *
   */
  //! @todo Refactor and abstract
  $field_label_map = array('related_manifestation_title' => 'Item Collection Title',
			   'related_loans_duration_elapsed' => 'Time Elapsed Between Loans');
  $field_type_map = array('related_manifestation_title' => 'nominal',
			  'related_loans_duration_elapsed' => 'ratio');

  $x_axis_label = array_key_exists($field_u, $field_label_map) ? $field_label_map[$field_u] : 'Sample';
  $x_axis_type = array_key_exists($field_u, $field_type_map) ? $field_type_map[$field_u] : 'nominal';

  $x_axis = array('label' => $x_axis_label,
		  'type' => $x_axis_type,
		  'axis' => 'x');

  $y_axis_label = array_key_exists($field_v, $field_label_map) ? $field_label_map[$field_v] : 'Quantity';
  $y_axis_type = array_key_exists($field_v, $field_type_map) ? $field_type_map[$field_v] : 'ratio';

  $y_axis = array('label' => $y_axis_label,
		  'type' => $y_axis_type,
		  'axis' => 'y');

  /*
   * Retrieve the data
   *
   */
  $data = array();

  switch($metric) {
      
  case 'sum':
  default:

    $samples = array_merge($data, dss_elc_metrics_bivariate_summation($bundle_u, $field_u, $bundle_v, $field_v));
  }

  // The closure passed to uasort() won't be invoked if the domain values for a single sample must be sorted
  foreach($samples as $domain => &$domain_values) {

    uasort($domain_values, function($domain_u, $domain_v) {

	if($domain_u == $domain_v) {

	  $result = 0;
	} else {

	  // This shall vary depending upon whether the values are sorted by minimum or maximum
	  $result = ($domain_u > $domain_v) ? -1 : 1;
	}

	return $result;
      });

    // Slice by a length specified within the site configuration
    $domain_values = array_slice($domain_values, 0, 10);
  }
  
  uasort($samples, function($domain_values_u, $domain_values_v) {

      $domain_values_u_init = reset($domain_values_u);
      $domain_values_v_init = reset($domain_values_v);

      if($domain_values_u_init == $domain_values_v_init) {

	$domain_values_u_length = count($domain_values_u);
	$domain_values_v_length = count($domain_values_v);

	if($domain_values_u_length == $domain_values_v_length) {

	  $result = 0;
	} else {

	  // Prefer the least number of values within the sample (for the purposes of slicing the array)
	  $result = ($domain_values_u_length < $domain_values_v_length) ? -1 : 1;
	}
      } else {

	// This shall vary depending upon whether the values are ordered by minimum or maximum
	$result = ($domain_values_u_init > $domain_values_v_init ? -1 : 1);
      }

      return $result;
    });

  //! @todo Reverse for sorting by the minimum

  // Slice by a length specified within the site configuration
  $samples = array_slice($samples, 0, 10);

  // Construct the labels
  $labels = array();

  // Structure the data for the NVD3 widget
  if($chart == 'bar' or $chart == 'line') {

    $domain_index = 0;
    foreach($samples as $group => $value) {

      $values = array();

      foreach($value as $x => $y) {

	// Assign arbitrary values for each member of the nominal set
	// Each value must map only to a single nominal value
	$labels[] = $x;
	
	$values[] = array('x' => $domain_index,
			  'y' => $y);

	$domain_index++;
      }

      $data[] = array('key' => $group,
		      'values' => $values);
    }
  } elseif($chart == 'cumulative_line') {

    foreach($samples as $group => $value) {

      $values = array();
      foreach($value as $x => $y) {

	$values[] = array($x, $y);
      }

      $data[] = array('key' => $group,
		      'values' => $values);
    }
  }

  $response = array('samples' => $data,
		    'labels' => $labels);

  return $response;
}

function _dss_elc_metrics_bivariate_deprecated($bundle_u, $field_u, $bundle_v, $field_v, $chart = 'bar', $metric_u = 'sum', $metric_v = 'sum') {

  /*
  // Refactor
  // Label mapping
  $info_u = field_info_instance('node', $field_u, $field_u == 'field_loan_duration' ? 'loan' : 'item');
  $info_v = field_info_instance('node', $field_v, 'human');

  $y_axis = array('label' => 'Loans',
		  'type' => 'ratio',
		  'axis' => 'y');

  // Refactor
  if(true) {

    $y_axis['property'] = 'value';
  }
  */

  // Wrap the Object with the appropriate metadata
  /*
  return array('data' => $output,
	       'metrics' => $metrics,
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
	       );
  */
  
  /**
   * Find all U entities related to V entities through relation R
   * This should be a simple SPARQL query, but ARC2 doesn't support PostgreSQL
   *
   */

  // First, retrieve every entity with this relationship

  // Retrieve all bundles from the ELC database sorted by the values for the field
  $query = db_select('node', 'n');

  $query->join("field_data_field_bib_rel_object", 'bib_rel_object', 'bib_rel_object.field_bib_rel_object_target_id=n.nid'); // Retrieve all field records for all NID's specified in the book loan records
  $query->join('node', 'loan', 'loan.nid=bib_rel_object.entity_id'); // Retrieve all related loan records
  $query->join("field_data_field_bib_rel_subject", 'bib_rel_subject', 'bib_rel_subject.entity_id=loan.nid'); // Retrieve all borrowers
  $query->join("field_data_field_loan_duration", 'loan_duration', 'loan_duration.entity_id=loan.nid'); // Retrieve the duration of the loan

  $query->condition('loan.type', 'loan', '=');
  $query->fields('bib_rel_object', array('field_bib_rel_object_target_id'));
  $query->fields('bib_rel_subject', array('field_bib_rel_subject_target_id'));
  $query->fields('loan_duration', array('field_loan_duration_value', 'field_loan_duration_value2'));

  /**
   * Need limited data set for testing
   * @todo Disable
   */
  $query->range(0,100);
  $records = $query->execute();

  $index = array();
  $json_record_values = array();

  /*
    $info = field_info_instance($entity_type, $field_name, $bundle_name);

    $label = $info['label'];
   */

  foreach($records as $record) {

    $_object = node_load($record->field_bib_rel_object_target_id);

    // If this is a manifestation, retrieve the original work
    if($_object->type == 'manifestation') {

      $entity_query = new EntityFieldQuery();
      $entity_query->entityCondition('entity_type', 'node');
      $entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
      $entities = $entity_query->execute();

      $_object = node_load(array_pop(array_keys($entities['node'])));
    }

    // Refactor
    if($field_u != 'field_loan_duration') {

      $_field_u = $_object->$field_u;
    }

    $_subject = node_load($record->field_bib_rel_subject_target_id);

    /**
     * @note Handling for List fields
     * Book/Periodical/Item: field_item_format
     * Human: field_human_gender
     *
     */
     $_field_v = $_subject->$field_v;

    // Refactor
    if(empty($_subject->$field_v)) {

      $_sample_name = 'Unknown';
    } else {
      
      if($field_v == 'field_human_gender') {

	$_field = field_info_field($field_v);
	$_values = list_allowed_values($_field);
	$_sample_name = array_pop($_field_v['und']);
	$_sample_name = $_values[$_sample_name['value']];
      } elseif($field_v == 'field_person_location' ||
	       $field_v == 'field_person_membership') {
	
	$entity_id = array_pop($_field_v['und']);
	$entity = node_load($entity_id['target_id']);
	
	$_sample_name = $entity->title;
      }
    }
    
    // For NULL List field values
    if(!$_sample_name) {
      
      $_sample_name = 'Unknown';
    }

    // Term Reference fields
    // Refactor for array
    if($field_u == 'field_human_occupation' ||
       $field_u == 'field_person_type' ||
       $field_u == 'field_item_subject' ||
       $field_u == 'field_artifact_type') {
      
      // For the handling of NULL values
      if(!$_field_u) {
	
	$_field_u = array('und' => array('Unknown'));
      }
      
      foreach($_field_u['und'] as $term) {
	  
	if(!array_key_exists('tid', $term)) {
	  
	  $domain = 'Unknown';
	} else {

	  $term = taxonomy_term_load($term['tid']);
	  $domain = $term->name;
	}

	if(!array_key_exists($domain, $json_record_values)) {

	  $json_record_values[$domain] = array($_sample_name => 1);	  
	} else {
	  
	  $json_record_values[$domain][$_sample_name]++;
	}
      }
    } elseif($field_u == 'field_artifact_was_authored_by') { // Entity References
      
      $entity_id = array_pop($_field_u['und']);
      $entity = node_load($entity_id['target_id']);
      
      $domain = $entity->field_person_name['und'][0]['value'];
      
      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_item_format') { // Refactor

      $_field = field_info_field($field_u);
      $_values = list_allowed_values($_field);
      $_domain = array_pop($_field_u['und']);
      $domain = $_values[$_domain['value']];

      // For NULL values
      if(!$domain) {

	$domain = 'Unknown';
      }

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }
    } elseif($field_u == 'field_loan_duration') { // Loan duration

      // Parse from a UNIX timestamp
      $domain = $record->field_loan_duration_value;
      $date = new DateObject($domain);
      $domain = $date->format('Ymd');

      // Refactor
      if(!array_key_exists($domain, $json_record_values)) {
	
	$json_record_values[$domain] = array($_sample_name => 1);
      } else {
	
	$json_record_values[$domain][$_sample_name]++;
      }

      // Also, set the type of scale to "temporal"
      $scale_type = 'temporal';
    }
  }

  $metrics = array();

  // Apply a linear transform for D3
  $output = array();
  foreach($json_record_values as $domain => $samples) {

    $sample_values = array();
    
    foreach($samples as $sample => $qty) {
      
      $sample_values[] = array('sample' => $sample,
			       'value' => $qty);

      $metrics[$sample] = array('sample' => $sample,
				'aMean' => mt_rand() / mt_getrandmax(),
				'median' => '{ ' . (string) (mt_rand() / mt_getrandmax()) . ' }',
				'mode' => mt_rand() / mt_getrandmax(),
				'kurtosisPearson' => mt_rand() / mt_getrandmax(),
				'kurtosisFisher' => mt_rand() / mt_getrandmax(),
				'distribution' => 'Poisson');
    }

    // Refactor
    if($field_u == 'field_loan_duration') {
     
      // Work-around
      $output[] = array('domain' => (string) $domain,
			'values' => $sample_values);
    } else {

      $output[] = array('domain' => $domain,
			'values' => $sample_values);
    }
  }

  // Refactor
  // Label mapping
  $info_u = field_info_instance('node', $field_u, $field_u == 'field_loan_duration' ? 'loan' : 'item');
  $info_v = field_info_instance('node', $field_v, 'human');

  $y_axis = array('label' => 'Loans',
		  'type' => 'ratio',
		  'axis' => 'y');

  // Refactor
  //if($field_u != 'field_loan_duration') {
  if(true) {

    $y_axis['property'] = 'value';
  }

  /*
	    var metrics = { 'sampleA' : {

		    sample: 'sampleA',
		    aMean: 3.45,
		    median: '{ ' + 4.56 + ' }',
		    mode: 7.68,
		    kurtosisPearson: 2.345,
		    kurtosisFisher: -1,
		    distribution: 'Poisson'
		},
			    'sampleB' : {

			    },
	    };
   */

  // Wrap the Object with the appropriate metadata
  return array('data' => $output,
	       'metrics' => $metrics,
	       'metadata' => array('x' => array('label' => $info_u['label'],
						'property' => 'domain',
						'type' => $scale_type ? $scale_type : 'nominal',
						'axis' => 'x'),
				   'y' => $y_axis)
	       );
}

function dss_elc_metrics_bivariate($bundle_u, $field_u, $bundle_v, $field_v, $chart, $metric) {
  
  /**
   * Disabling caching for the moment
   */
  //dss_elc_metrics_cache_call(array($bundle_u, $field_u, $bundle_v, $field_v, $metric), '_dss_elc_metrics_bivariate');

  return _dss_elc_metrics_bivariate($bundle_u, $field_u, $bundle_v, $field_v, $chart, $metric);
}

function dss_elc_metrics_network_explore($node, $depth, &$network, &$neighbors = array(), &$labels = array()) {

  if($depth == 0) {

    return;
  }

  // For a given node, retrieve the relationships

  //$neighbors = array();

  // If this is a derived from the Person bundle...
  //! @todo Extend for Families, Clubs, Churches, Businesses, and other Organizations
  if(in_array($node->type, array('human'))) {

    // retrieve the loans/authorships related to this node
    // (Yields Items)
    $query = array('(sm_field_bib_rel_subject:"node:' . $node->nid . '" OR sm_field_loan_shareholder:"node:' . $node->nid . '")');

    list($query, $results) = dss_elc_metrics_solr_query(array('loan', 'authorship'), $query, 1000000);

    $loan_docs = $results->response->docs;

    foreach($loan_docs as $loan_doc) {

      $neighbor_nids = $loan_doc->sm_field_bib_rel_object;

      if(!empty($neighbor_nids)) {

	$neighbor_nid = array_shift($neighbor_nids);

	// Retrieve the title and type
	preg_match('/node\:(\d+)/', $neighbor_nid, $m);
	$neighbor_nid = $m[1];

	$query = array('entity_id:' . $neighbor_nid);
	list($query, $results) = dss_elc_metrics_solr_query(array('*'), $query, 1);

	$neighbor_docs = $results->response->docs;
	$neighbor_doc = array_shift($neighbor_docs);

	$neighbor_type = $neighbor_doc->bundle;
	$neighbor_title = $neighbor_doc->label;

	$neighbor = array('nid' => $neighbor_nid,
			  'type' => $neighbor_type,
			  'title' => $neighbor_title);
	$neighbor = (object) $neighbor;

	if(!array_key_exists($neighbor->nid, $labels)) {

	  // Update the labels
	  $labels[$neighbor->nid] = $neighbor->title;
	}

	// If this node hasn't been explored yet...
	if(!in_array($neighbor->nid, $neighbors)) {

	  // Add the node to the network
	  if(!array_key_exists($node->nid, $network)) {

	    $network[$node->nid] = array();
	  }

	  if(!array_key_exists($neighbor->nid, $network[$node->nid])) {

	    $network[$node->nid][$neighbor->nid] = 1;
	  } else {

	    $network[$node->nid][$neighbor->nid]++;
	  }

	  // Add the node to the discovered neighbors
	  $neighbors[] = $neighbor;
	}
      }
    }
    
    // retrieve the personal relationships related to this node
    // (Yields Representatives)

    $query = array('sm_field_pers_rel_subject:"node:' . $node->nid . '"');

    list($query, $results) = dss_elc_metrics_solr_query(array('personal_relationship'), $query, 1000000);

    $pers_rel_docs = $results->response->docs;
    foreach($pers_rel_docs as $pers_rel_doc) {

      $neighbor_nids = $pers_rel_doc->sm_field_pers_rel_object;

      if(!empty($neighbor_nids)) {

	$neighbor_nid = array_shift($neighbor_nids);


	/*
	$neighbor_nid = array_shift($neighbor_nids);

	// Retrieve the title and type
	preg_match('/node\:(\d+)/', $neighbor_nid, $m);
	$query = array('entity_id:' . $m[1]);
	list($query, $results) = dss_elc_metrics_solr_query(array('*'), $query, 1);

	$neighbor_docs = $results->response->docs;
	$neighbor_doc = array_shift($neighbor_docs);

	$neighbor_type = $neighbor_doc->bundle;
	$neighbor_title = $neighbor_doc->label;

	$neighbor = array('nid' => $neighbor_nid,
			  'type' => $neighbor_type,
			  'title' => $neighbor_title);
	$neighbor = (object) $neighbor;

	if(!array_key_exists($neighbor->nid, $labels)) {

	  // Update the labels
	  $labels[$neighbor->nid] = $neighbor->title;
	}
	 */

	// Retrieve the title
	preg_match('/node\:(\d+)/', $neighbor_nid, $m);
	$neighbor_nid = $m[1];

	$query = array('entity_id:' . $neighbor_nid);
	list($query, $results) = dss_elc_metrics_solr_query(array('*'), $query, 1);

	$neighbor_docs = $results->response->docs;
	$neighbor_doc = array_shift($neighbor_docs);

	//$neighbor_type = $neighbor_doc->bundle;
	$neighbor_title = $neighbor_doc->label;

	$neighbor = array('nid' => $neighbor_nid,
			  'type' => 'human',
			  'title' => $neighbor_title
			  );
	$neighbor = (object) $neighbor;

	// Update the labels
	$labels[$neighbor->nid] = $neighbor->title;

	//$neighbors[] = $neighbor;
	// If this node hasn't been explored yet...
	if(!in_array($neighbor->nid, $neighbors)) {

	  // Add the node to the network
	  if(!array_key_exists($node->nid, $network)) {

	    $network[$node->nid] = array();
	    $labels[$node->nid] = $node->title;
	  }

	  if(!array_key_exists($neighbor->nid, $network[$node->nid])) {

	    $network[$node->nid][$neighbor->nid] = 1;
	  } else {

	    $network[$node->nid][$neighbor->nid]++;
	  }

	  // Add the node to the discovered neighbors
	  $neighbors[] = $neighbor;
	}
      }
    }
  } elseif(in_array($node->type, array('item', 'book', 'periodical'))) {

    // If this is (or, is a derived from) the Item bundle...

    // retrieve the loans/authorships related to this node
    // (Yields Representatives and Authors)
    $query = array('sm_field_bib_rel_object:"node:' . $node->nid . '"');

    list($query, $results) = dss_elc_metrics_solr_query(array('loan', 'authorship'), $query, 1000000);

    $loan_docs = $results->response->docs;
    foreach($loan_docs as $loan_doc) {

      $neighbor_nids = $loan_doc->sm_field_bib_rel_subject;

      if(!empty($neighbor_nids)) {

	$neighbor_nid = array_shift($neighbor_nids);

	// Retrieve the title and type
	/*
	$query = array('entity_id:' . $neighbor->nid);
	list($query, $results) = dss_elc_metrics_solr_query(array('*'), $query, 1);

	$neighbor_docs = $results->response->docs;
	$neighbor_doc = array_shift($neighbor_docs);

	$neighbor_title = $neighbor_doc->bundle;
	*/

	// Retrieve the title
	preg_match('/node\:(\d+)/', $neighbor_nid, $m);
	$neighbor_nid = $m[1];

	$query = array('entity_id:' . $neighbor_nid);
	list($query, $results) = dss_elc_metrics_solr_query(array('*'), $query, 1);

	$neighbor_docs = $results->response->docs;
	$neighbor_doc = array_shift($neighbor_docs);

	//$neighbor_type = $neighbor_doc->bundle;
	$neighbor_title = $neighbor_doc->label;

	$neighbor = array('nid' => $neighbor_nid,
			  'type' => 'human',
			  'title' => $neighbor_title,
			  );
	$neighbor = (object) $neighbor;

	//$neighbors[] = $neighbor;
	// If this node hasn't been explored yet...
	if(!in_array($neighbor->nid, $neighbors)) {

	  // Add the node to the network
	  if(!array_key_exists($node->nid, $network)) {

	    $network[$node->nid] = array();
	    $labels[$node->nid] = $node->title;
	  }

	  if(!array_key_exists($neighbor->nid, $network[$node->nid])) {

	    $network[$node->nid][$neighbor->nid] = 1;
	  } else {

	    $network[$node->nid][$neighbor->nid]++;
	  }

	  // Add the node to the discovered neighbors
	  $neighbors[] = $neighbor;
	}
      }
    }
  }

  // Retrieve the object of each relationship
  // Increment the depth
  $depth--;

  // Iterate through each relationship...
  foreach($neighbors as $neighbor) {

    // And for each related node, recurse
    // (Ideally, this would be implemented using concurrency, but time prevents this from being properly implemented)
    dss_elc_metrics_network_explore($neighbor, $depth, $network, $neighbors, $labels);
  }
}

/**
 * Explore the network to a certain depth for a given set of nodes
 * (This is formatted in a manner which can be deserialized for networkx in Python)
 */
//function _dss_elc_metrics_network($relationship_bundle, $nids, $min=NULL, $max=NULL, $depth = 1) {
function _dss_elc_metrics_network($nids, $depth = 1) {

  $network = array();
  $neighbors = array();
  $labels = array();

  foreach($nids as $nid) {

    //! @todo Refactor
    if(!empty($nid)) {

      // Retrieve the title
      /*
      preg_match('/node\:(\d+)/', $nid, $m);
      $nid = $m[1];
      */

      $query = array('entity_id:' . $nid);
      list($query, $results) = dss_elc_metrics_solr_query(array('human'), $query, 1);

      $node_docs = $results->response->docs;
      $node_doc = array_shift($node_docs);

      $node = array('nid' => $nid,
		    'type' => 'human',
		    'title' => $node_doc->label);
      $node = (object) $node;

      $neighbors[] = $node;
      $labels[$node->nid] = $node->title;

      dss_elc_metrics_network_explore($node, $depth, $network, $neighbors, $labels);
    }
  }

  $response = array('data' => $network,
		    'labels' => $labels);

  return $response;
}

function _dss_elc_metrics_network_deprecated($relationship_bundle, $nids, $min=NULL, $max=NULL) {
  
  if($relationship_bundle == 'loan') {

    $mongo_id = json_encode($nids);
    $collection_name = 'dss_elc_metrics_loans';

    /**
     * @todo Integrate
     */
    //$loan_entities = dss_elc_metrics_cache_get($mongo_id, $collection_name);
    $loan_entities = NULL;

    if(!isset($loan_entities)) {

      // Cache the loans fetched for any given subject
      $entity_query = new EntityFieldQuery();
      $entity_query->entityCondition('entity_type', 'node');
      $entity_query->entityCondition('bundle', 'loan');
      $entity_query->fieldCondition('field_bib_rel_subject', 'target_id', $nids, 'IN');

      if(isset($max)) {

	if($max < 0) {

	  $min_date = date('c', $min);
	  $max_date = date('c', $max);

	  $entity_query->fieldCondition('field_loan_duration', 'value', array((int) $max, (int) $min), 'BETWEEN');
	} else {

	  $entity_query->range((int) $min - 1, (int) $max);
	}
      }

      $entities = $entity_query->execute();
      $loan_entities = node_load_multiple(array_keys($entities['node']));

      //print json_encode($loan_entities);

      /**
       * @todo Integrate
       */
      //dss_elc_metrics_cache_set($mongo_id, json_encode($loan_entities), $collection_name);
    }

    // Avoid confusing Drupal "nodes" with network nodes
    $vertices = array();
    $indexed_edges = array();

    // Refactor
    $indexed_vertex_ids = array();

    foreach($loan_entities as $loan_entity) {

      if(isset($min_date) and isset($max_date)) {
	
	/**
	 * Work-around
	 * This will become unnecessary after integrating with DateTime
	 *
	 */
	if((float) $loan_entity->field_loan_duration_value < (float) $min_date ||
	   (float) $loan_entity->field_loan_duration_value > (float) $max_date) {

	  //continue;
	}
      }

      $lang = $loan_entity->language;

      /*
      $_object = $loan_entity->field_bib_rel_object->$lang;
      $_object = node_load(intval($_object[0]->target_id));
      */
      $_object = $loan_entity->field_bib_rel_object[$lang];
      $_object = node_load(intval($_object[0]['target_id']));

      // If this is a manifestation, retrieve the original work
      if($_object->type == 'manifestation') {
	
	$entity_query = new EntityFieldQuery();
	$entity_query->entityCondition('entity_type', 'node');
	$entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
	$entities = $entity_query->execute();
	
	$_object = node_load(array_pop(array_keys($entities['node'])));
      }

      /*
      $_subject = $loan_entity->field_bib_rel_subject->$lang;
      $_subject = node_load(intval($_subject[0]->target_id));
      */
      $_subject = $loan_entity->field_bib_rel_subject[$lang];
      $_subject = node_load(intval($_subject[0]['target_id']));
      
      // Refactor
      if(!array_key_exists($_subject->nid, $indexed_vertex_ids)) {
	
	$vertices[] = array('label' => $_subject->title,
			    'type' => $_subject->type);
	
	$indexed_vertex_ids[$_subject->nid] = sizeof($vertices) - 1;
      }
      
      // Refactor
      if(!array_key_exists($_object->nid, $indexed_vertex_ids)) {
	
	$vertices[] = array('label' => $_object->title,
			    'type' => $_object->type);
	
	$indexed_vertex_ids[$_object->nid] = sizeof($vertices) - 1;
      }
      
      if(!array_key_exists($_subject->nid, $indexed_edges)) {
	
	$indexed_edges[$_subject->nid] = array($_object->nid => array('source' => $indexed_vertex_ids[$_subject->nid],
								      //'target' => $subject_vertex_id + 1,
								      //'target' => sizeof($vertices),
								      'target' => $indexed_vertex_ids[$_object->nid],
								      'weight' => 1,
								      'type' => 'borrowedBy'));
	
      } elseif(!array_key_exists($_object->nid, $indexed_edges[$_subject->nid])) {
	
	$indexed_edges[$_subject->nid][$_object->nid] = array(//'source' => $subject_vertex_id,
							      'source' => $indexed_vertex_ids[$_subject->nid],
							      //'target' => $subject_vertex_id + 1,
								//'target' => sizeof($vertices),
							      'target' => $indexed_vertex_ids[$_object->nid],
							      'weight' => 1,
							      'type' => 'borrowedBy');
      } else {
	
	// Increase the weight for more than one loan for any given work
	$indexed_edges[$_subject->nid][$_object->nid]['weight']++;
      }
    }
  } elseif($relationship_bundle == 'personal_relationship') {

    $mongo_id = json_encode($nids);
    $collection_name = 'dss_elc_metrics_loans';

    /**
     * @todo Integrate
     */
    //$pers_rel_entities = dss_elc_metrics_cache_get($mongo_id, $collection_name);
    $pers_rel_entities = NULL;

    if(!isset($pers_rel_entities)) {

      // Cache the loans fetched for any given subject
      $entity_query = new EntityFieldQuery();
      $entity_query->entityCondition('entity_type', 'node');
      $entity_query->entityCondition('bundle', 'personal_relationship');
      $entity_query->fieldCondition('field_pers_rel_subject', 'target_id', $nids, 'IN');

      if(isset($max)) {

	$entity_query->range((int) $min - 1, (int) $max);
      }
      
      $entities = $entity_query->execute();
      $pers_rel_entities = node_load_multiple(array_keys($entities['node']));

      /**
       * @todo Integrate
       */
      //dss_elc_metrics_cache_set($mongo_id, json_encode($pers_rel_entities), $collection_name);
    }

    // Avoid confusing Drupal "nodes" with network nodes
    $vertices = array();
    $indexed_edges = array();

    // Refactor
    $indexed_vertex_ids = array();

    foreach($pers_rel_entities as $pers_rel_entity) {

      $lang = $pers_rel_entity->language;

      /*
      $_object = $pers_rel_entity->field_pers_rel_object->$lang;
      $_object = node_load(intval($_object[0]->target_id));
      */
      $_object = $pers_rel_entity->field_pers_rel_object[$lang];
      $_object = node_load(intval($_object[0]['target_id']));

      // If this is a manifestation, retrieve the original work
      if($_object->type == 'manifestation') {
	
	$entity_query = new EntityFieldQuery();
	$entity_query->entityCondition('entity_type', 'node');
	$entity_query->fieldCondition('field_item_embodies', 'target_id', $_object->nid, '=');
	$entities = $entity_query->execute();
	
	$_object = node_load(array_pop(array_keys($entities['node'])));
      }

      /*
      $_subject = $pers_rel_entity->field_pers_rel_subject->$lang;
      $_subject = node_load(intval($_subject[0]->target_id));
      */
      $_subject = $pers_rel_entity->field_pers_rel_subject[$lang];
      $_subject = node_load(intval($_subject[0]['target_id']));

      /**
       * Load the term for the role within the personal relationship
       */
      $role_term = taxonomy_term_load($pers_rel_entity->field_pers_rel_role[$lang][0]['tid']);
      
      // Refactor
      if(!array_key_exists($_subject->nid, $indexed_vertex_ids)) {

	/**
	 * For personal relationships, a more granular type of node is specified.
	 */
	$vertices[] = array('label' => $_subject->title,
			    //'type' => $_subject->type
			    'type' => $role_term->name
			    );
	
	$indexed_vertex_ids[$_subject->nid] = sizeof($vertices) - 1;
      }
      
      // Refactor
      if(!array_key_exists($_object->nid, $indexed_vertex_ids)) {
	
	/**
	 * For personal relationships, a more granular type of node is specified.
	 */
	$vertices[] = array('label' => $_object->title,
			    //'type' => $_object->type
			    'type' => 'Shareholder'
			    );
	
	$indexed_vertex_ids[$_object->nid] = sizeof($vertices) - 1;
      }

      if(!array_key_exists($_subject->nid, $indexed_edges)) {
	
	$indexed_edges[$_subject->nid] = array($_object->nid => array('source' => $indexed_vertex_ids[$_subject->nid],
								      //'target' => $subject_vertex_id + 1,
								      //'target' => sizeof($vertices),
								      'target' => $indexed_vertex_ids[$_object->nid],
								      'weight' => 1,
								      'type' => $role_term->name));
	
      } elseif(!array_key_exists($_object->nid, $indexed_edges[$_subject->nid])) {
	
	$indexed_edges[$_subject->nid][$_object->nid] = array(//'source' => $subject_vertex_id,
							      'source' => $indexed_vertex_ids[$_subject->nid],
							      //'target' => $subject_vertex_id + 1,
								//'target' => sizeof($vertices),
							      'target' => $indexed_vertex_ids[$_object->nid],
							      'weight' => 1,
							      'type' => $role_term->name);
      } else {
	
	// Increase the weight for more than one loan for any given work
	$indexed_edges[$_subject->nid][$_object->nid]['weight']++;
      }
    }
  }

  $edges = array();
  
  // Flatten the array for D3
  foreach($indexed_edges as $subject_nid => $value) {
    
    foreach($value as $object_nid => $edge) {
      
      $edges[] = $edge;
    }
  }

  /**
   * Ensure that, if nothing else, the nodes for the humans are visualized
   */
  if(empty($vertices)) {

    foreach($nids as $nid) {

      $node = node_load($nid);
      if(isset($node->title)) {

	$vertices[] = array('label' => $node->title,
			    'type' => 'human');
      }
    }
  }

  /**
   *
   * Fixtures for development
   * @todo Remove for testing
   */

  if($relationship_bundle == 'personal_relationship') {

    $vertices[] = array('label' => '(Son)',
			'type' => 'Child');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'isChildOf');

    $vertices[] = array('label' => '(Mother)',
			'type' => 'Parent');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'isParentOf');

    $vertices[] = array('label' => '(Father)',
			'type' => 'Parent');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'isParentOf');

    $vertices[] = array('label' => '(Employee)',
			'type' => 'Employee');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'hasEmployee');

    $vertices[] = array('label' => '(Servant)',
			'type' => 'Servant');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'hasServant');

    $vertices[] = array('label' => '(Brother)',
			'type' => 'Sibling');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'isSiblingOf');

    $vertices[] = array('label' => 'First Presbyterian Church',
			'type' => 'Church');
    $edges[] = array('source' => count($vertices) - 1,
		     'target' => 0,
		     'weight' => 1,
		     'type' => 'isMemberOf');
  }

  // Wrap the Object with the appropriate metadata
  return array('data' => array('nodes' => $vertices,
			       'links' => $edges),
	       'metadata' => array()
	       );
}

/**
 * @author griffinj
 * Visualizing bivariate analyses
 *
 */
function dss_elc_metrics_get_bivariate_ajax() {

  if(empty($_POST)) {

    // Communicating using JSON

    // The inputstream module should be utilized here in order to avoid breaking when more than one module accesses the stream concurrently:
    $data = file_get_contents("php://input");
    $data = json_decode($data, TRUE);

    drupal_json_output($data);
  } else {

    foreach(array('bundle_u', 'field_u', 'bundle_v', 'field_v', 'chart', 'metric') as $param) {

      if(array_key_exists($param, $_POST)) {

	$data[$param] = $_POST[$param];
	//$object[$param] = $_POST[$param];
      }
    }

    /*
    $data = array('data' => $data['data']
			'metadata' => $data['metadata']);
    */
  }

  if(!empty($data)) {
    
    // The JSON must be normalized
    if(array_keys($data) === array('bundle_u', 'field_u', 'bundle_v', 'field_v', 'chart', 'metric')) {

      drupal_json_output(dss_elc_metrics_bivariate($data['bundle_u'], $data['field_u'], $data['bundle_v'], $data['field_v'], $data['chart'], $data['metric']));
    }
  }

}

/**
 * @abstract
 * Implementing a separate MongoDB cache for the Objects generated
 *
 */
/*
function dss_elc_metrics_cache_get($params, $callback, $force_update=FALSE) {

  //$params = array('loan', array('125645'), '-5005047600', '-4859982000');

  $collection = mongodb_collection('dss_elc_metrics');
  $mongo_id = json_encode($params);

  $data = $collection->findOne(array('_id' => $mongo_id));

  if($force_update || (!$data || !isset($data['data']))) {

    //$object = dss_elc_metrics_network('loan', array('125645'), '-5005047600', '-4859982000');
    $object = call_user_func_array($callback, $params);

    $doc = array('_id' => $mongo_id,
		 'cid' => $mongo_id,
		 //'created' => REQUEST_TIME,
		 //'expire' => $expire,
		 //'serialized' => !$scalar,
		 //'data' => $scalar ? $data : serialize($data),
		 'data' => $object);

    $collection->save($doc);

    $data = $object;
  }

  return $data;
}
*/

/**
 * @author griffinj
 * Visualizing network analyses
 *
 */
function dss_elc_metrics_get_network_ajax() {

  if(empty($_POST)) {

    // Communicating using JSON

    // The inputstream module should be utilized here in order to avoid breaking when more than one module accesses the stream concurrently:
    $data = file_get_contents("php://input");
    $data = json_decode($data, TRUE);
  } else {

    // Refactor
    foreach(array('bundle', 'subject_nids', 'limit', 'depth') as $param) {

      if(array_key_exists($param, $_POST)) {

	$data[$param] = $_POST[$param];
      }
    }
  }

  if(!empty($data)) {

    if(!array_key_exists('limit', $data)) {

      $data['limit'] = NULL;
    }

    // The JSON must be normalized
    //if(array_keys($data) === array('bundle', 'subject_nids', 'limit', 'depth')) {
    //if(array_keys($data) === array('subject_nids')) {

    $diff = array_diff(array_keys($data), array('bundle', 'subject_nids', 'limit', 'depth'));

    if(empty($diff)) {

      // Normalize Drupal form data
      if(gettype($data['subject_nids']) == 'string') {

	$subject_nids = array();

	foreach(preg_split('/\)/', $data['subject_nids']) as $value) {

	  preg_match('/\((\d+)/', $value, $matches);
	  $subject_nids[] = $matches[1];
	}

	$data['subject_nids'] = $subject_nids;
      }

      /*
      // Normalize Drupal form data
      if(array_key_exists('value2', $data['limit'])) {

	$min_date = (float) $data['limit']['value'];
	$max_date = (float) $data['limit']['value2'];

	//$min_date = (string) (-5005047600000 + $min_date*259200000);
	//$max_date = (string) (-4859982000000 - (560 - $max_date)*259200000);

	$min_date = (string) (-5005047600 + $min_date*259200);
	$max_date = (string) (-4859982000 - (560 - $max_date)*259200);
      }
      */

      // Caching
      //return drupal_json_output(dss_elc_metrics_network($data['bundle'], $data['subject_nids'], $min_date, $max_date));

      /*
      if(array_key_exists('value2', $data['limit']) and array_key_exists('value', $data['limit'])) {

	return drupal_json_output(_dss_elc_metrics_network($data['bundle'], $data['subject_nids'], $data['limit']['value'], $data['limit']['value2']));
      } else {

	return drupal_json_output(_dss_elc_metrics_network($data['bundle'], $data['subject_nids']));
      }
      */

      return drupal_json_output(_dss_elc_metrics_network($data['subject_nids'], $data['depth']));
    }
  }
}

/*
 * Function for server-side pre-processing of the the browse people functionality of the website.
 * this returns a JSON object which will be sent to the webpage for DataTables implementation.
 *
 */
function dss_elc_metrics_get_people($request) {

  $request = !is_null($request) ? $request : $_GET;

	$query = new EntityFieldQuery();
	
	/*
	//choosing which column has been clicked for sorting
	switch($_GET['order']['0']['column']){
		
		case 0://author
			$sort_value = 'title';
			break;
			
		case 1://title
			$sort_value = 'changed';
			break;

		default:
			$sort_value = 'title';
			break;
	}
	*/

	$sort_value_map = array('sort_label',
				'is_changed');
	
	$sort_value = $sort_value_map[intval($request['order']['0']['column'])];

	/**
	 * griffinj@lafayette.edu
	 * Integrate MongoDB caching for unfiltered data sets
	 * @todo Refactor for hook implementations
	 */
	$sort_dir = $_GET['order']['0']['dir'];
	// Extend for sorting involving start values
	// Resolves EDDC-367
	$start = $_GET['start'];

	$rows = $_GET['length'];

	list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('views_datatables_cache');

	// @todo Refactor into a map/reduce operation?
	$filtered_by_search = FALSE;
	foreach($_GET['columns'] as $columnar_data) {

	  //$filtered_by_search = trim($columnar_data['search']['value']) != '' or $filtered_by_search;
	  $filtered_by_search = !empty($columnar_data['search']['value']) + $filtered_by_search;
	}

	if(!$filtered_by_search) {

	  // Generate the Document pseudo-key for the MongoDB based upon the sorting parameters
	  //$mongo_key = 'views_datatables_cache_people_' . $sort_value . '_' . $sort_dir . '_' . $sort_begin;
	  $mongo_key = dss_elc_metrics_views_datatables_mongo_key('views_datatables_cache', 'items', $sort_value, $sort_dir, $start, $rows);

	  // Retrieve the cached data set from the MongoDB
	  $cached_datatable_json = $mongo_collection->findOne(array('view' => $mongo_key));
	  //if($cached_datatable_json) {
	  if(false) {

	    $data = $cached_datatable_json['data'];
	    $data['draw'] = intval($_GET['draw']) + 1;

	    return drupal_json_output($data);
	  } else {
	    
	    // ...and if this data set hasn't been cached, prepare for delayed response
	    set_time_limit(420);
	  }
	}

	list($final_query, $solr_response) = dss_elc_metrics_datatables_query(array('human'), $request);

	//print_r($final_query);
	//print_r( $solr_response);
	//exit(1);

	$datatable_json = dss_elc_metrics_datatables_response($solr_response, array('human'));

	/**
	 * @author griffinj@lafayette.edu
	 * Consistently update the MongoDB cache for cases in which the results were not filtered
	 * @todo Invoke a hook implementation
	 *
	 */
	if(!$filtered_by_search) {

	  //$mongo_collection->insert(array('view' => $mongo_key, 'data' => $datatable_json));
	  $mongo_collection->update(array('view' => $mongo_key),
				    array('view' => $mongo_key, 'data' => $datatable_json),
				    array('upsert' => TRUE));
	}
  
	if(true) {
    
	  return drupal_json_output($datatable_json);
	}

	exit(1);

	//query for getting human nodes in the sorted in the specified order
	$query->addMetaData('account', user_load(1))
	->entityCondition('entity_type','node')
	->entityCondition('bundle','human')
	->propertyOrderBy($sort_value,$_GET['order']['0']['dir']);	
	if($_GET['columns']['0']['search']['value'] != ''){
		
		$query->fieldCondition('field_person_name', 'value', $_GET['columns']['0']['search']['value'],'CONTAINS');
		
	}
	//implement this with radio button when it is created
	if($_GET['authors']!='true'){
		$query->fieldCondition('field_person_type','tid','230','!=');
	}
	
	//count the number of items that are displayed with these search values
	$result = $query->execute();
	$display_size = count($result['node']);
	
	//get only the cache size worth of people
	$result = $query->range(intval($_GET['start']),intval($_GET['start'])+intval($_GET['length']))
			  ->execute();		  
	//loading nodes from query
    $nodes = entity_load('node', array_keys($result['node']));
	
	//query only for determining iTotalDisplayRecords and iTotalRecords -- these will be different once search is implemented
	$total_query = new EntityFieldQuery();
	
	//implement this with radio button when it is created
	if($_GET['authors']!='true'){
		$total_query->fieldCondition('field_person_type','tid','230','!=');
	}
	
	//correctly formatting the JSON return object metadata
	$datatable_json =  array(
	    "draw" => intval($_GET['draw'])+1,
	    "iTotalRecords" => intval($total_query
	    	->entityCondition('entity_type','node')
			->entityCondition('bundle','human')
			->count()
			->execute()),
	    "iTotalDisplayRecords" => $display_size,
	    "aaData" => array() 	  
	     );
		 
	//correctly formatting the JSON return object aaData
	$count = 0;
	
	foreach ($nodes as $key => $value) {
		if(isset($value)){	
			$datatable_json['aaData'][$count] = array($value->title,$value->revision_timestamp,$value->nid,$value->nid);
		}
		else{
			$datatable_json['aaData'][$count] = array('');
		}
		$count++;
	}
	
	return drupal_json_output($datatable_json);
	
}

/**
 * @author griffinj@lafayette.edu
 *
 * Function for transforming DataTables arrays for Manifestation Content Nodes
 *
 * @param [Array] $results Structured array record to be parsed by DataTables
 * @return [Array] An array of Manifestation Objects
 */

function _dss_elc_metrics_items_record_transform($manifestation, $author, $volume_term, $subject_term) {

  $record = array($author->title, $manifestation->title,$volume_term->name,$manifestation->type,$subject_term->name,$manifestation->revision_timestamp,$manifestation->nid,$manifestation->nid);

  $items = dss_elc_items_by_manifestation($manifestation);

  // If there were items in relation to this manifestation...
  if(count($items) > 0) {

    $term_map = function($term_ref) {

      $term = taxonomy_term_load($term_ref['tid']);
      return $term->name;
    };

    // Retrieve the volumes for the related items
    $volume_refs = array();

    // @todo Refactor into a map
    foreach($items as $i => $item) {

      $volume_refs[] = $item->field_item_volume_migrate[$item->language][0];
    }

    $volumes = array_map($term_map, $volume_refs);
    // Sort by the value for the array (i. e. the volume number itself)
    sort($volumes);
    
    $first_item = reset($items);
    
    // Retrieve the subject terms for the first item
    $subjects = array_map($term_map, $first_item->field_item_subject[$item->language]);

    // Capitalize the Content Node Type
    $type = ucfirst($first_item->type);

    $record = array($author->title, $manifestation->title, $volumes, $type, $subjects, $first_item->revision_timestamp, $first_item->nid, $first_item->nid);
  }

  return $record;
}

/**
 * @author griffinj@lafayette.edu
 * For sorting the records rendered within the View
 *
 */

function _dss_elc_metrics_items_records_sort($records, $field = 'title', $order = 'asc') {

  if($field == 'field_item_subject') {
    
    $sort = function($record_u, $record_v) {

      // Search on the first value
      $subject_u = $record_u[4][0];
      $subject_v = $record_v[4][0];

      return strcmp($subject_u, $subject_v);
    };

    usort($sort, $records);

    if($order == 'desc') {

      $records = array_reverse($records);
    }
  } elseif($field == 'field_item_volume_migrate') {

    $sort = function($record_u, $record_v) {

      // Search on the first value
      $subject_u = $record_u[2][0];
      $subject_v = $record_v[2][0];

      return strcmp($subject_u, $subject_v);
    };

    usort($sort, $records);

    if($order == 'desc') {

      $records = array_reverse($records);
    }
  }

  return $records;
}

/**
 * @author griffinj@lafayette.edu
 * For integration with the MongoDB for caching
 * @todo Migrate into the module dss_elc_mongodb
 *
 */
function _dss_elc_mongodb_get_collection($collection_name = 'views_datatables_cache', $db = 'dss_elc_mongodb', $options = array()) {

  $host = variable_get('dss_elc_metrics_mongodb_host', 'mongodb://santorini0.stage.lafayette.edu');

  //$mongo = new Mongo($host, $options);
  $mongo = new MongoClient($host, $options);
  $mongo_db = $mongo->selectDB($db);
  $mongo_collection = $mongo_db->selectCollection($collection_name);

  return array($mongo_collection, $mongo);
}

/*
 * Function for server-side pre-processing of the the browse items functionality of the website.
 * this returns a json object wnich will be sent to the webpage for DataTables implementation.
 * @author stathisw@lafayette.edu
 */
function dss_elc_metrics_get_items($request = NULL) {

  $request = !is_null($request) ? $request : $_GET;
	
	//Declaring query object
	$query = new EntityFieldQuery();
	
	/*
	//choosing which column has been clicked for sorting
	switch(intval($_GET['order']['0']['column'])){
		
	case 0://author
			$sort_value = 'field_artifact_was_authored_by';
			break;
			
		case 1://title
			$sort_value = 'title';
			break;
			
		case 2://vols.
			$sort_value = 'field_item_volume_migrate';
			break;
		
		case 3://type
			$sort_value = 'type';
			break;
			
		case 4://subject
		        $sort_value = 'field_item_subject';
			break;
			
		case 5://modified
			$sort_value = 'changed';
			break;
			
		default:
			$sort_value = 'title';
			break;
			
	}
	*/

	$sort_value_map = array('sort_field_artifact_was_authored_by_label',
				'sort_label',
				'is_field_item_volume_migrate',
				'bundle',
				'sort_field_item_subject',
				'is_changed');
	
	$sort_value = $sort_value_map[intval($request['order']['0']['column'])];

	/**
	 * griffinj@lafayette.edu
	 * Integrate MongoDB caching for unfiltered data sets
	 * @todo Refactor for hook implementations
	 */
	$sort_dir = $_GET['order']['0']['dir'];
	// Extend for sorting involving start values
	// Resolves EDDC-367
	$start = $_GET['start'];
	$row = $_GET['length'];

	list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('views_datatables_cache');

	// @todo Refactor into a map/reduce operation?
	$filtered_by_search = FALSE;
	foreach($_GET['columns'] as $columnar_data) {

	  //$filtered_by_search = trim($columnar_data['search']['value']) != '' or $filtered_by_search;
	  $filtered_by_search = !empty($columnar_data['search']['value']) + $filtered_by_search;
	}

	if(!$filtered_by_search) {

	  // Generate the Document pseudo-key for the MongoDB based upon the sorting parameters
	  //$mongo_key = 'views_datatables_cache_items_' . $sort_value . '_' . $sort_dir . '_' . $sort_begin;
	  $mongo_key = dss_elc_metrics_views_datatables_mongo_key('views_datatables_cache', 'items', $sort_value, $sort_dir, $start, $rows);

	  // Retrieve the cached data set from the MongoDB
	  $cached_datatable_json = $mongo_collection->findOne(array('view' => $mongo_key));
	  if($cached_datatable_json) {

	    $data = $cached_datatable_json['data'];
	    $data['draw'] = intval($_GET['draw']) + 1;

	    return drupal_json_output($data);
	  } else {
      
	    // ...and if this data set hasn't been cached, prepare for delayed response
	    set_time_limit(420);
	  }
	}

	list($final_query, $solr_response) = dss_elc_metrics_datatables_query(array('item', 'book', 'periodical'), $request);
	$datatable_json = dss_elc_metrics_datatables_response($solr_response, array('item', 'book', 'periodical'));

	/**
	 * @author griffinj@lafayette.edu
	 * Consistently update the MongoDB cache for cases in which the results were not filtered
	 * @todo Invoke a hook implementation
	 *
	 */
	if(!$filtered_by_search) {

	  $mongo_collection->insert(array('view' => $mongo_key, 'data' => $datatable_json));
	}
  
	if(true) {
    
	  return drupal_json_output($datatable_json);
	}

	exit(1);

	//If we are sorting by any column other than author, volumes, or subject, do this
	if($sort_value != 'field_artifact_was_authored_by' && $sort_value != 'field_item_volume_migrate' && $sort_value != 'field_item_subject'){
		//query for getting books sorted in the appropriate way
		$query->addMetaData('account', user_load(1))
		->entityCondition('entity_type','node')
		->entityCondition('bundle','manifestation')
		->propertyOrderBy($sort_value,$_GET['order']['0']['dir']);
		
		$result = $query->execute();
		
		//load the nodes
		$nodes = entity_load('node', array_keys($result['node']));
		
		
	}
	//If we are sorting by the author, volumes, or subject
	else{
		
		//getting a query for all books
		$result = $query->entityCondition('entity_type','node')
		->entityCondition('bundle','manifestation')
		->execute();
		
		//loading nodes from book query
		$nodes = entity_load('node', array_keys($result['node']));
		
		switch($sort_value){
			
			//sort all of the books by getting author names and compare them
			case 'field_artifact_was_authored_by': 
				usort($nodes,function($a,$b){
					
					$author_node_a = entity_load('node', array($a->field_artifact_was_authored_by['und'][0]['target_id']));
					$author_node_b = entity_load('node', array($b->field_artifact_was_authored_by['und'][0]['target_id']));
					return strcasecmp(trim($author_node_a[$a->field_artifact_was_authored_by['und'][0]['target_id']]->title), trim($author_node_b[$b->field_artifact_was_authored_by['und'][0]['target_id']]->title));
					
			});
			break;
			
			//sort all of the books by getting their volume number and compare them
			case 'field_item_volume_migrate': 
				usort($nodes,function($a,$b){
					$taxonomy_volume_a = taxonomy_term_load($a->field_item_volume_migrate['und'][0]['tid']);
					$taxonomy_volume_b = taxonomy_term_load($b->field_item_volume_migrate['und'][0]['tid']);
					
					if(intval($taxonomy_volume_a->name) > intval($taxonomy_volume_b->name)){
						return 1;
					}
					elseif(intval($taxonomy_volume_a->name) < intval($taxonomy_volume_b->name)){
						return -1;
					}
					else{
						return 0;	
					}
						
			});
			break;
			
			//sort all of the books by getting their subjects and compare them
			case 'field_item_subject': 
				usort($nodes,function($a,$b){
					
					$taxonomy_term_a = taxonomy_term_load($a->field_item_subject['und'][0]['tid']);
					$taxonomy_term_b = taxonomy_term_load($b->field_item_subject['und'][0]['tid']);
					return strcasecmp(trim($taxonomy_term_a->name), trim($taxonomy_term_b->name));
					
			});
			break;
		}
		
		//If the order is descending, flip the arrays
		if($_GET['order']['0']['dir']=='desc'){
			$nodes = array_reverse($nodes);
		}
		
	}

	//empties the array of all nodes which do not contain the search value
	
	//search by author
	if(trim($_GET['columns']['0']['search']['value'])!=''){
		$nodes = array_filter($nodes, function($var){
			 
				$author_node = entity_load('node', array($var->field_artifact_was_authored_by['und'][0]['target_id']));
				return stristr($author_node[$var->field_artifact_was_authored_by['und'][0]['target_id']]->title, $_GET['columns']['0']['search']['value']);
				
		});
		
	}
	
	//search by item title
	if(trim($_GET['columns']['1']['search']['value'])!=''){
		$nodes = array_filter($nodes,function($var){
		
			return stristr($var->title,$_GET['columns']['1']['search']['value']);
		
		});
		
	}	
	
	//search by volume number
	if(trim($_GET['columns']['2']['search']['value'])!=''){
		$nodes = array_filter($nodes, function($var){
			 	$taxonomy_volume = taxonomy_term_load($var->field_item_volume_migrate['und'][0]['tid']);
				return $taxonomy_volume->name == $_GET['columns']['2']['search']['value'];
		});
		
	}
	
	//search by type
	if(trim($_GET['columns']['3']['search']['value'])!=''){
		$nodes = array_filter($nodes, function($var){
			 
				return stristr($var->type, $_GET['columns']['3']['search']['value']);
				
		});
		
	}
	
	//search by subject
	if(trim($_GET['columns']['4']['search']['value'])!=''){
		$nodes = array_filter($nodes, function($var){
			 
				$taxonomy_subject = taxonomy_term_load($var->field_item_subject['und'][0]['tid']);
				return stristr($taxonomy_subject->name, $_GET['columns']['4']['search']['value']);
				
		});
		
	}
	
	//count the number of items that are displayed witht these search values
	$display_size = count($nodes);
	
	//get only the cache size worth of objects
	$nodes = array_slice($nodes, intval($_GET['start']),intval($_GET['length']));
	
	//a query for determining the total number of results, used only for iTotalDisplayRecords and iTotalRecords These will be different once searching is implemented
	$total_query = new EntityFieldQuery();
	
	//correctly formatting the JSON return object metadata
	$datatable_json =  array(
	    "draw" => intval($_GET['draw'])+1,
	    "iTotalRecords" => intval($total_query
	    	->entityCondition('entity_type','node')
			->entityCondition('bundle','manifestation')
			->count()
			->execute()),
	    "iTotalDisplayRecords" => $display_size,
	    "aaData" => array() 	  
	     );

	/**
	 * @author griffinj@lafayette.edu
	 * Transform the data set to be parsed by DataTables
	 *
	 */

	//correctly formatting the JSON return object aaData
	$count = 0;
	foreach ($nodes as $key => $value) {
	                if(isset($value)){
			$taxonomy_volumes = taxonomy_term_load($value->field_item_volume_migrate['und'][0]['tid']);
			$taxonomy_subject = taxonomy_term_load($value->field_item_subject['und'][0]['tid']);
			$author_node = entity_load('node', array($value->field_artifact_was_authored_by['und'][0]['target_id']));

			/**
			 * @author griffinj@lafayette.edu
			 * Transform the record
			 */

			//$datatable_record = array($author_node[$value->field_artifact_was_authored_by['und'][0]['target_id']]->title,$value->title,$taxonomy_volumes->name,$value->type,$taxonomy_subject->name,$value->revision_timestamp,$value->nid,$value->nid);

			$author = $author_node[$value->field_artifact_was_authored_by['und'][0]['target_id']];

			// @todo Integrate sorting
			$datatable_record = _dss_elc_metrics_items_record_transform($value, $author, $taxonomy_volumes, $taxonomy_subject);

			$datatable_json['aaData'][$count] = $datatable_record;
		}
		else{
			$datatable_json['aaData'][$count] = array('');
		}
		$count++;
	}

	/**
	 * @author griffinj@lafayette.edu
	 * For extending the sorting functionality for transformed records (e. g. sorting against related Item/Book/Volume values)
	 *
	 */
	$datatable_json['aaData'] = _dss_elc_metrics_items_records_sort($datatable_json['aaData'], $sort_value, $sort_dir);

	/**
	 * @author griffinj@lafayette.edu
	 * Consistently update the MongoDB cache for cases in which the results were not filtered
	 * @todo Invoke a hook implementation
	 *
	 */
	if(!$filtered_by_search) {

	  //$mongo_collection->insert(array('view' => $mongo_key, 'data' => $datatable_json));
	  $mongo_collection->update(array('view' => $mongo_key),
				    array('view' => $mongo_key, 'data' => $datatable_json),
				    array('upsert' => TRUE));
	}

	return drupal_json_output($datatable_json);
}

function dss_elc_metrics_apachesolr_index_document_build($document, $entity, $entity_type) {

  /**
   * Expose certain fields for Solr to index
   * These shall need to explicitly dereference certain field values (i. e. references)
   *
   */

  if($entity_type == 'node') {

    if($entity->type == 'loan') {

      // For Loans, the following fields must be filtered:
      // Shareholder (dereferenced)
      // Representative (dereferenced)
      // Checkout
      // Vols
      // Modified

      //field_loan_shareholder
      //field_bib_rel_subject
      //field_bib_rel_object
      //field_loan_duration
      //field_loan_volumes_loaned
      //changed

      foreach(array('field_loan_shareholder',
		    'field_bib_rel_subject',
		    'field_bib_rel_object'
		    ) as $entity_reference_field) {

	/*
	  $shareholder = node_load($entity->field_loan_shareholder[$entity->language][0]['target_id']);
	  $representative = $entity->field_bib_rel_subject[$entity->language][0]['target_id'];
	  $item = $entity->field_bib_rel_object[$entity->language][0]['target_id'];

	  $document->addField('ts_field_loan_shareholder_label', $shareholder->title);
	  $document->addField('ts_field_bib_rel_subject_label', $representative->title);
	  $document->addField('ts_field_bib_rel_object_label', $item->title);
	*/
	
	if(property_exists($entity, $entity_reference_field) and !empty($entity->{$entity_reference_field}[$entity->language])) {

	  $entity_reference = node_load($entity->{$entity_reference_field}[$entity->language][0]['target_id']);

	  //watchdog('dss_elc_metrics', 'entity title: %title', array('%title' => $entity_reference->title, WATCHDOG_NOTICE));
	  $document->addField("ss_" . $entity_reference_field . "_label", $entity_reference->title);
	}
      }


      foreach(array('field_loan_duration') as $entity_field) {

	if(property_exists($entity, $entity_field) and !empty($entity->{$entity_field}[$entity->language])) {

	  $document->addField("is_" . $entity_field . "_value", $entity->{$entity_field}[$entity->language][0]['value']);
	}
      }

      // Vols.
      foreach(array('field_loan_volumes_loaned') as $entity_field) {

	if(property_exists($entity, $entity_field) and !empty($entity->{$entity_field}[$entity->language])) {

	  $document->addField("is_" . $entity_field . "_first", intval($entity->{$entity_field}[$entity->language][0]['value']));
	}
      }

      $document->addField('is_changed', $entity->changed);
    } else if($entity->type == 'item' or
	      $entity->type == 'book' or
	      $entity->type == 'periodical') {

      foreach(array('field_artifact_was_authored_by') as $entity_reference_field) {

	if(property_exists($entity, $entity_reference_field) and !empty($entity->{$entity_reference_field}[$entity->language])) {

	  // Add the custom field
	  $entity_reference = node_load($entity->{$entity_reference_field}[$entity->language][0]['target_id']);
	  $document->addField("ss_" . $entity_reference_field . "_label", $entity_reference->title);
	}
      }

      //$document->addField("ss_label", $entity->title);

      /*
      if(property_exists($entity, 'field_item_volume_migrate') and !empty($entity->field_item_volume_migrate[$entity->language])) {

	watchdog('dss_elc_metrics', 'type item_volume_migrate: %type', array('%type' => $entity->field_item_volume_migrate[$entity->language][0], WATCHDOG_NOTICE));
	$document->addField("ss_field_item_volume_migrate", $entity->field_item_volume_migrate[$entity->language][0]);
      }
      */

      /*
      foreach(array('field_artifact_type') as $entity_field) {

	$type_map = array(0 => 'book',
			  1 => 'periodical');
	
	if(property_exists($entity, $entity_field) and !empty($entity->{$entity_field}[$entity->language])) {
	  
	  watchdog('dss_elc_metrics', 'type constant: %type', array('%type' => $type_map[$entity->{$entity_field}[$entity->language][0]['value']], WATCHDOG_NOTICE));
	  $document->addField("ss_" . $entity_field . "_constant", $type_map[$entity->{$entity_field}[$entity->language][0]['value']]);
	}
      }
      */

      foreach(array('field_item_volume_migrate',
		    ) as $taxon_field) {

	if(property_exists($entity, $taxon_field) and !empty($entity->{$taxon_field}[$entity->language])) {

	  $subject = taxonomy_term_load($entity->{$taxon_field}[$entity->language][0]['tid']);
	  $document->addField("is_" . $taxon_field, $subject->name);
	}
      }

      foreach(array('field_item_subject',
		    //'field_artifact_type'
		    ) as $taxon_field) {

	if(property_exists($entity, $taxon_field) and !empty($entity->{$taxon_field}[$entity->language])) {

	  $subject = taxonomy_term_load($entity->{$taxon_field}[$entity->language][0]['tid']);
	  $document->addField("ss_" . $taxon_field, $subject->name);
	}
      }

      $document->addField('is_changed', $entity->changed);
    } else if($entity->type == 'human') {

      watchdog('dss_elc_metrics', 'type constant: %title', array('%title' => $entity->title, WATCHDOG_NOTICE));

      //$document->addField("ss_label", $entity->title);
      $document->addField('is_changed', $entity->changed);
    }
  }
}

/**
 *
 * Transform the collection of Solr documents within a response into a DataTables JSON Object
 *
 */
function dss_elc_metrics_datatables_response($response, $bundles) {

  $total_records = variable_get('dss_elc_metrics_views_datatables_' . $bundles[0] . '_total_records', $response->response->numFound);

  //correctly formatting the JSON return object metadata
  $datatable_json = array("draw" => intval($_GET['draw'])+1,
			  "iTotalRecords" => $total_records,
			  "iTotalDisplayRecords" => $response->response->numFound,
			  "aaData" => array()
			  );

  foreach($response->response->docs as $count => $doc) {

    // For handling Loan Nodes
    if(in_array('loan', $bundles)) {

      $datatable_json['aaData'][$count] = array($doc->ss_field_loan_shareholder_label,
						$doc->ss_field_bib_rel_subject_label,
						$doc->is_field_loan_duration_value,
						$doc->ss_field_bib_rel_object_label
						);

      array_push($datatable_json['aaData'][$count],
		 implode(',', $doc->sm_field_loan_volumes_loaned),
		 strtotime($doc->ds_last_comment_or_change),
		 $doc->entity_id,
		 $doc->entity_id);
    } elseif(in_array('item', $bundles)) {

      // For handling Item, Book, and Periodical Nodes
      $item_type_constant = (property_exists($doc, $ss_field_artifact_type_constant) and !empty($doc->ss_field_artifact_type_constant)) ? $doc->ss_field_artifact_type_constant : $doc->bundle_name;

      $datatable_json['aaData'][$count] = array(!is_null($doc->ss_field_artifact_was_authored_by_label) ? $doc->ss_field_artifact_was_authored_by_label : '[Illegible]',
						$doc->label,
						$doc->im_field_item_volume_migrate[0],
						$item_type_constant,
						$doc->ss_field_item_subject,
						strtotime($doc->ds_last_comment_or_change),
						$doc->entity_id,
						$doc->entity_id
						);

    } elseif(in_array('human', $bundles)) {

      // For handling Human Nodes
      $datatable_json['aaData'][$count] = array($doc->label,
						strtotime($doc->ds_last_comment_or_change),
						$doc->entity_id,
						$doc->entity_id
						);
    }
  }

  return $datatable_json;
}



function dss_elc_metrics_views_datatables_mongo_key($prefix, $view, $sort_value, $sort_dir, $start, $rows, $nid = NULL) {

  $mongo_key = implode('_', array($prefix, $view, $sort_value, $sort_dir, $start, $rows));

  if(!is_null($nid)) {

    $mongo_key .= preg_replace('/\:/', '_', $nid);
  }

  return $mongo_key;
}

/**
 * Callback for retrieving loans
 *
 */
function dss_elc_metrics_get_loans($request = NULL) {

  $request = !is_null($request) ? $request : $_GET;
  $nid = array_key_exists('nid', $request) ? $nid : NULL;

  $filter_query = NULL;

  if(!is_null($nid)) {

    $filter_query = '(sm_field_bib_rel_subject:"' . $nid . '" OR sm_field_bib_rel_object:"' . $nid . '")';
  }

  //Declaring query object
  $query = new EntityFieldQuery();
  
  /*
  //choosing which column has been clicked for sorting
  switch(intval($request['order']['0']['column'])){
    
  case 0://shareholder
    //$sort_value = 'field_loan_shareholder';
    $sort_value = 'sm_field_loan_shareholder_label';
    break;
    
  case 1://representative
    //$sort_value = 'field_bib_rel_subject';
    $sort_value = 'sm_field_bib_rel_subject_label';
    break;
    
  case 2://checkout
    $sort_value = 'dm_field_loan_duration';
    break;
    
  case 3://item title
    //$sort_value = 'field_bib_rel_object';
    $sort_value = 'sm_field_bib_rel_object_label';
    break;
    
  case 4://vols
    //$sort_value = 'field_loan_volumes_loaned';
    $sort_value = 'sm_field_loan_volumes_loaned';
    break;
    
  case 5://modified
    //$sort_value = 'changed';
    $sort_value = 'sm_changed';
    break;
			
  default:
    //$sort_value = 'title';
    $sort_value = 'label';
    break;
    
  }
  */

  $sort_value_map = array('sort_field_loan_shareholder_label',
			  'sort_field_bib_rel_subject_label',
			  'is_field_loan_duration_value',
			  'sort_field_bib_rel_object_label',
			  'is_field_loan_volumes_loaned_first',
			  'is_changed');

  $sort_value = $sort_value_map[intval($request['order']['0']['column'])];

  /**
   * griffinj@lafayette.edu
   * Integrate MongoDB caching for unfiltered data sets
   * @todo Refactor for hook implementations
   */

  $sort_dir = $request['order']['0']['dir'];
  // Extend for sorting involving start values
  // Resolves EDDC-367
  $start = $request['start'];
  
  $row = $request['length'];
  
  // Caching for non-filtered responses
  list($mongo_collection, $mongo) = _dss_elc_mongodb_get_collection('views_datatables_cache');
  
  // @todo Refactor into a map/reduce operation?
  $filtered_by_search = FALSE;
  foreach($request['columns'] as $columnar_data) {
    
    //$filtered_by_search = trim($columnar_data['search']['value']) != '' or $filtered_by_search;
    $filtered_by_search = !empty($columnar_data['search']['value']) + $filtered_by_search;
  }

  if(!$filtered_by_search) {

    // Generate the Document pseudo-key for the MongoDB based upon the sorting parameters

    if(!is_null($nid)) {

      $mongo_key = dss_elc_metrics_views_datatables_mongo_key('views_datatables_cache', 'loans', $sort_value, $sort_dir, $start, $rows, preg_replace('/\:/', '_', $nid));
    } else {

      // Generate the Document pseudo-key for the MongoDB based upon the sorting parameters
      //$mongo_key = 'views_datatables_cache_loans_' . $sort_value . '_' . $sort_dir . '_' . $start . '_' . $rows;
      $mongo_key = dss_elc_metrics_views_datatables_mongo_key('views_datatables_cache', 'loans', $sort_value, $sort_dir, $start, $rows);
    }
    
    // Retrieve the cached data set from the MongoDB
    $cached_datatable_json = $mongo_collection->findOne(array('view' => $mongo_key));
    if($cached_datatable_json) {
      
      $data = $cached_datatable_json['data'];
      $data['draw'] = intval($request['draw']) + 1;
      
      return drupal_json_output($data);
    } else {

      // ...and if this data set hasn't been cached, prepare for delayed response
      set_time_limit(420);
    }
  }

  //list($final_query, $response) = apachesolr_do_query($query);
  list($final_query, $solr_response) = dss_elc_metrics_datatables_query(array('loan'), $request, $filter_query);
  $datatable_json = dss_elc_metrics_datatables_response($solr_response, array('loan'));

  /**
   * @author griffinj@lafayette.edu
   * Consistently update the MongoDB cache for cases in which the results were not filtered
   * @todo Invoke a hook implementation
   *
   */
  if(!$filtered_by_search) {
    
    $mongo_collection->update(array('view' => $mongo_key),
			      array('view' => $mongo_key, 'data' => $datatable_json),
			      array('upsert' => TRUE));
  }
  
  if(true) {
    
    return drupal_json_output($datatable_json);
  }
  exit(1);
  
  //If we are sorting by last changed date
  if($sort_value == 'changed'){
    //query for getting books sorted in the appropriate way
    $query->addMetaData('account', user_load(1))
      ->entityCondition('entity_type','node')
      ->entityCondition('bundle','loan')
      ->propertyOrderBy($sort_value,$_GET['order']['0']['dir']);
    
    $result = $query->execute();
    
    //load the nodes
    $nodes = entity_load('node', array_keys($result['node']));
    
  }
  //We are sorting by any other field 
	else{
		//getting a query for all loans
		$result = $query->addMetaData('account', user_load(1))
		->entityCondition('entity_type','node')
		->entityCondition('bundle','loan')
		->execute();
		
		//loading nodes from book query
		$loans = entity_load('node', array_keys($result['node']));
		
		//sort all of the books by using $sort_value
		
		//case for sorting by shareholder, representative, or item title
		if($sort_value != 'field_loan_volumes_loaned'||'field_loan_duration'){			
			switch($sort_value){
			
				case 'field_loan_shareholder':	
					usort($loans,function($a,$b){
						$sort_node_a = entity_load('node', array($a->field_loan_shareholder['und']['0']['target_id']));
						$sort_node_b = entity_load('node', array($b->field_loan_shareholder['und']['0']['target_id']));
						return strcasecmp(trim($sort_node_a[$a->field_loan_shareholder['und']['0']['target_id']]->title), trim($sort_node_b[$b->field_loan_shareholder['und']['0']['target_id']]->title));
					});
					break;
					
				case 'field_bib_rel_subject' :
					usort($loans,function($a,$b){
						$sort_node_a = entity_load('node', array($a->field_bib_rel_subject['und']['0']['target_id']));
						$sort_node_b = entity_load('node', array($b->field_bib_rel_subject['und']['0']['target_id']));
						return strcasecmp(trim($sort_node_a[$a->field_bib_rel_subject['und']['0']['target_id']]->title), trim($sort_node_b[$b->field_bib_rel_subject['und']['0']['target_id']]->title));					
					});
					break;
				
				case 'field_bib_rel_object' :
					usort($loans,function($a,$b){
						$sort_node_a = entity_load('node', array($a->field_bib_rel_object['und']['0']['target_id']));
						$sort_node_b = entity_load('node', array($b->field_bib_rel_object['und']['0']['target_id']));
						return strcasecmp(trim($sort_node_a[$a->field_bib_rel_object['und']['0']['target_id']]->title), trim($sort_node_b[$b->field_bib_rel_object['und']['0']['target_id']]->title));
					});
					break;	
			}
				
		}
		
		//case for sorting by checkout date
		if($sort_value == 'field_loan_duration'){
			usort($loans,function($a,$b){
				if($a->field_loan_duration['und']['0']['value'] == $b->field_loan_duration['und']['0']['value']){
					return 0;
				}
				elseif($a->field_loan_duration['und']['0']['value'] > $b->field_loan_duration['und']['0']['value']){
					return 1;
				}
				elseif($a->field_loan_duration['und']['0']['value'] < $b->field_loan_duration['und']['0']['value']){
					return -1;
				}
			});
		}

		//case for sorting by volume
		if($sort_value == 'field_loan_volumes_loaned'){
			usort($loans,function($a,$b){
				$a_vols = 0;
				$b_vols = 0;
				foreach($a->field_loan_volumes_loaned['und'] as $key => $value){
					$a_vols < $value['value'] ? $a_vols = $value['value'] : $a_vols = $a_vols ;
				}
				foreach($b->field_loan_volumes_loaned['und'] as $key => $value){
					$b_vols < $value['value'] ? $b_vols = $value['value'] : $b_vols = $b_vols ;
				}
				
				if($a_vols == $b_vols){
					return 0;
				}
				elseif($a_vols > $b_vols){
					return 1;
				}
				elseif($a_vols < $b_vols){
					return -1;
				}
			});	
		}
		
		$nodes = $loans;
		
		//if it is descending, reverse the order
		if($_GET['order']['0']['dir']=='desc'){
			$nodes = array_reverse($nodes);
		}

	}

	//empties the array of all nodes which do not contain the search value
	
	//searching shareholder
	if(trim($_GET['columns']['0']['search']['value'])!=''){
		$nodes = array_filter($nodes, function($var){
				$shareholder_node = entity_load('node', array($var->field_loan_shareholder['und'][0]['target_id']));
				return stristr($shareholder_node[$var->field_loan_shareholder['und'][0]['target_id']]->title, $_GET['columns']['0']['search']['value']);
				
		});	
	}

	//searching representative
	if(trim($_GET['columns']['1']['search']['value'])!=''){

		$nodes = array_filter($nodes,function($var){
				
			$representative_node = entity_load('node', array($var->field_bib_rel_subject['und'][0]['target_id']));
			return stristr($representative_node[$var->field_bib_rel_subject['und'][0]['target_id']]->title,$_GET['columns']['1']['search']['value']);
		
		});
	}
	//searching title
	if(trim($_GET['columns']['3']['search']['value'])!=''){
		$nodes = array_filter($nodes,function($var){
		
			$item_node = entity_load('node', array($var->field_bib_rel_object['und'][0]['target_id']));
			return stristr($item_node[$var->field_bib_rel_object['und'][0]['target_id']]->title,$_GET['columns']['3']['search']['value']);
		
		});
	}
	//searching  Vols.
	if(trim($_GET['columns']['4']['search']['value'])!=''){
		
		$nodes = array_filter($nodes,function($var){
			$found = false;
			foreach($var->field_loan_volumes_loaned['und'] as $key => $value){
					stristr($value['value'],$_GET['columns']['4']['search']['value']) ? $found = true : $found=$found ;
				}
			return $found;
		
		});
	}	
	
	//count the number of items that are displayed witht these search values
	$display_size = count($nodes);
						
	//get only the cache size worth of objects
	$nodes = array_slice($nodes, intval($_GET['start']),intval($_GET['length']));
	

	//a query for determining the total number of results, used only for iTotalDisplayRecords and iTotalRecords These will be different once searching is implemented
	$total_query = new EntityFieldQuery();
	
	//correctly formatting the JSON return object metadata
	$datatable_json =  array(
	    "draw" => intval($_GET['draw'])+1,
	    "iTotalRecords" => intval($total_query
	    	->entityCondition('entity_type','node')
			->entityCondition('bundle','loan')
			->count()
			->execute()),
	    "iTotalDisplayRecords" => $display_size,
	    "aaData" => array() 	  
	     );

	/**
	 * @author griffinj@lafayette.edu
	 * Transform the data set to be parsed by DataTables
	 *
	 */

	//correctly formatting the JSON return object aaData
	$count = 0;
	foreach ($nodes as $key => $value) {
		if(isset($value)){
			$shareholder_node = entity_load('node', array($value->field_loan_shareholder['und'][0]['target_id']));
			$representative_node = entity_load('node', array($value->field_bib_rel_subject['und'][0]['target_id']));
			$item_node = entity_load('node', array($value->field_bib_rel_object['und'][0]['target_id']));

			/**
			 * @author griffinj@lafayette.edu
			 * Normalize the record (?)
			 */

			$shareholder_name = $shareholder_node[$value->field_loan_shareholder['und'][0]['target_id']]->title;
			$representative_name = $representative_node[$value->field_loan_shareholder['und'][0]['target_id']]->title;
			$loan_duration = $value->field_loan_duration['und']['0']['value'];
			$item_title = $item_node[$value->field_bib_rel_object['und'][0]['target_id']]->title;

			$datatable_json['aaData'][$count] = array($shareholder_name, $representative_name, $loan_duration, $item_title);

			$these_vols = '';
			
			foreach($value->field_loan_volumes_loaned['und'] as $vol_key => $vol_value){
				
				if($these_vols == ''){
					
					$these_vols = $vol_value['value'];
					
				}
				else{
					
					$these_vols = $these_vols . ',' . $vol_value['value'];
					
				}
			}
			array_push($datatable_json['aaData'][$count],
			$these_vols,
			$value->revision_timestamp,
			$value->nid,
			$value->nid);
		
		}
		else{
			$datatable_json['aaData'][$count] = array('');
		}
		$count++;
	}

	/**
	 * @author griffinj@lafayette.edu
	 * For extending the sorting functionality for transformed records (e. g. sorting against related Item/Book/Volume values)
	 *
	 */
	$datatable_json['aaData'] = _dss_elc_metrics_items_records_sort($datatable_json['aaData'], $sort_value, $sort_dir);

	/**
	 * @author griffinj@lafayette.edu
	 * Consistently update the MongoDB cache for cases in which the results were not filtered
	 * @todo Invoke a hook implementation
	 *
	 */
	if(!$filtered_by_search) {

	  $mongo_collection->insert(array('view' => $mongo_key, 'data' => $datatable_json));
	}


	return drupal_json_output($datatable_json);
	
}

